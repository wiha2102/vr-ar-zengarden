import { STANDARD_AXES, STANDARD_AXES_MAPPING, STANDARD_BUTTONS, STANDARD_BUTTON_MAPPING, } from './standard-mapping.js';
import { XR_STANDARD_AXES, XR_STANDARD_AXES_MAPPING, XR_STANDARD_BUTTONS, XR_STANDARD_BUTTON_MAPPING, } from './xr-standard-mapping.js';
export class GamepadWrapper {
    constructor(gamepad, options = {}) {
        var _a, _b, _c;
        this._buttons = [];
        this._gamepad = gamepad;
        this._buttonPressValueMin = (_a = options.buttonPressValueMin) !== null && _a !== void 0 ? _a : 0;
        this._buttonPressValueMax = (_b = options.buttonPressValueMax) !== null && _b !== void 0 ? _b : 1;
        this._buttonClickThreshold = (_c = options.buttonClickThreshold) !== null && _c !== void 0 ? _c : 0.9;
        for (let buttonIdx = 0; buttonIdx < this._gamepad.buttons.length; buttonIdx++) {
            this._buttons[buttonIdx] = {
                currFrame: {
                    value: 0,
                    touched: false,
                },
                prevFrame: {
                    value: 0,
                    touched: false,
                },
                pressedSince: 0,
            };
        }
    }
    update() {
        for (let buttonIdx = 0; buttonIdx < this._gamepad.buttons.length; buttonIdx++) {
            this._buttons[buttonIdx].prevFrame = this._buttons[buttonIdx].currFrame;
            this._buttons[buttonIdx].currFrame = {
                value: this._gamepad.buttons[buttonIdx].value,
                touched: this._gamepad.buttons[buttonIdx].touched,
            };
        }
    }
    get gamepad() {
        return this._gamepad;
    }
    getButtonIdx(buttonId) {
        const buttonIdx = this._gamepad.mapping == 'standard'
            ? STANDARD_BUTTON_MAPPING[buttonId]
            : this._gamepad.mapping == 'xr-standard'
                ? XR_STANDARD_BUTTON_MAPPING[buttonId]
                : null;
        if (buttonIdx == null) {
            throw `Button "${buttonId}" does not exist in layout "${this._gamepad.mapping}"`;
        }
        else {
            return buttonIdx;
        }
    }
    getAxisIdx(axisId) {
        const axisIdx = this._gamepad.mapping == 'standard'
            ? STANDARD_AXES_MAPPING[axisId]
            : this._gamepad.mapping == 'xr-standard'
                ? XR_STANDARD_AXES_MAPPING[axisId]
                : null;
        if (axisIdx == null) {
            throw `Axis "${axisId}" does not exist in layout "${this._gamepad.mapping}"`;
        }
        else {
            return axisIdx;
        }
    }
    getButtonValueByIndex(buttonIdx) {
        if (this._buttons[buttonIdx]) {
            return this._buttons[buttonIdx].currFrame.value;
        }
        else {
            return 0;
        }
    }
    getButtonValue(buttonId) {
        const buttonIdx = this.getButtonIdx(buttonId);
        return this.getButtonValueByIndex(buttonIdx);
    }
    getButtonByIndex(buttonIdx) {
        if (this._buttons[buttonIdx]) {
            return (this._buttons[buttonIdx].currFrame.value > this._buttonPressValueMin);
        }
        else {
            return false;
        }
    }
    getButton(buttonId) {
        const buttonIdx = this.getButtonIdx(buttonId);
        return this.getButtonByIndex(buttonIdx);
    }
    getButtonDownByIndex(buttonIdx) {
        if (this._buttons[buttonIdx]) {
            return (this._buttons[buttonIdx].prevFrame.value <= this._buttonPressValueMin &&
                this._buttons[buttonIdx].currFrame.value > this._buttonPressValueMin);
        }
        else {
            return false;
        }
    }
    getButtonDown(buttonId) {
        const buttonIdx = this.getButtonIdx(buttonId);
        return this.getButtonDownByIndex(buttonIdx);
    }
    getButtonUpByIndex(buttonIdx) {
        if (this._buttons[buttonIdx]) {
            return (this._buttons[buttonIdx].prevFrame.value >= this._buttonPressValueMax &&
                this._buttons[buttonIdx].currFrame.value < this._buttonPressValueMax);
        }
        else {
            return false;
        }
    }
    getButtonUp(buttonId) {
        const buttonIdx = this.getButtonIdx(buttonId);
        return this.getButtonUpByIndex(buttonIdx);
    }
    getButtonClickByIndex(buttonIdx) {
        if (this._buttons[buttonIdx]) {
            return (this._buttons[buttonIdx].prevFrame.value <=
                this._buttonClickThreshold &&
                this._buttons[buttonIdx].currFrame.value > this._buttonClickThreshold);
        }
        else {
            return false;
        }
    }
    getButtonClick(buttonId) {
        const buttonIdx = this.getButtonIdx(buttonId);
        return this.getButtonClickByIndex(buttonIdx);
    }
    getAxisByIndex(axisIdx) {
        return this._gamepad.axes[axisIdx];
    }
    getAxis(axisId) {
        const axisIdx = this.getAxisIdx(axisId);
        return this.getAxisByIndex(axisIdx);
    }
    get2DInputAngle(buttonId) {
        const axisX = this.getAxis(buttonId + '_X');
        const axisY = this.getAxis(buttonId + '_Y');
        if (axisX == null || axisY == null || (axisX == 0 && axisY == 0)) {
            return NaN;
        }
        let rad = Math.atan(axisX / axisY);
        if (axisX >= 0) {
            if (axisY < 0) {
                rad *= -1;
            }
            else if (axisY > 0) {
                rad = Math.PI - rad;
            }
            else if (axisY == 0) {
                rad = Math.PI / 2;
            }
        }
        else {
            if (axisY < 0) {
                rad *= -1;
            }
            else if (axisY > 0) {
                rad = -Math.PI - rad;
            }
            else if (axisY == 0) {
                rad = -Math.PI / 2;
            }
        }
        return rad;
    }
    get2DInputValue(buttonId) {
        const axisX = this.getAxis(buttonId + '_X');
        const axisY = this.getAxis(buttonId + '_Y');
        return Math.sqrt(axisX * axisX + axisY * axisY);
    }
    getHapticActuator(actuatorIdx) {
        // @ts-ignore
        const hapticActuator = this._gamepad.hapticActuators[actuatorIdx];
        if (!hapticActuator) {
            throw 'Requested haptic actuator does not exist in gamepad';
        }
        else {
            return hapticActuator;
        }
    }
}
export const BUTTONS = {
    STANDARD: STANDARD_BUTTONS,
    XR_STANDARD: XR_STANDARD_BUTTONS,
};
export const AXES = {
    STANDARD: STANDARD_AXES,
    XR_STANDARD: XR_STANDARD_AXES,
};
export { STANDARD_AXES, STANDARD_BUTTONS, XR_STANDARD_AXES as XR_AXES, XR_STANDARD_BUTTONS as XR_BUTTONS, };
//# sourceMappingURL=index.js.map