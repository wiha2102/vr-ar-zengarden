/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { WebXRFeatures, PRIVATE as XRDEVICE_PRIVATE, } from '../device/XRDevice.js';
import { PRIVATE as XRFRAME_PRIVATE, XRFrame } from '../frameloop/XRFrame.js';
import { XRInputSourcesChangeEvent, } from '../events/XRInputSourcesChangeEvent.js';
import { XRReferenceSpace, XRReferenceSpaceType, } from '../spaces/XRReferenceSpace.js';
import { XRRenderState } from './XRRenderState.js';
import { XRSessionEvent, } from '../events/XRSessionEvent.js';
import { XREye } from '../views/XRView.js';
import { PRIVATE as XRSPACE_PRIVATE } from '../spaces/XRSpace.js';
import { PRIVATE as XRWEBGLLAYER_PRIVATE } from '../layers/XRWebGLLayer.js';
import { mat4 } from 'gl-matrix';
export var XRVisibilityState;
(function (XRVisibilityState) {
    XRVisibilityState["Visible"] = "visible";
    XRVisibilityState["VisibleBlurred"] = "visible-blurred";
    XRVisibilityState["Hidden"] = "hidden";
})(XRVisibilityState || (XRVisibilityState = {}));
export var XRSessionMode;
(function (XRSessionMode) {
    XRSessionMode["Inline"] = "inline";
    XRSessionMode["ImmersiveVR"] = "immersive-vr";
    XRSessionMode["ImmersiveAR"] = "immersive-ar";
})(XRSessionMode || (XRSessionMode = {}));
export var XREnvironmentBlendMode;
(function (XREnvironmentBlendMode) {
    XREnvironmentBlendMode["Opaque"] = "opaque";
    XREnvironmentBlendMode["AlphaBlend"] = "alpha-blend";
    XREnvironmentBlendMode["Additive"] = "additive";
})(XREnvironmentBlendMode || (XREnvironmentBlendMode = {}));
export var XRInteractionMode;
(function (XRInteractionMode) {
    XRInteractionMode["ScreenSpace"] = "screen-space";
    XRInteractionMode["WorldSpace"] = "world-space";
})(XRInteractionMode || (XRInteractionMode = {}));
export const PRIVATE = Symbol('@immersive-web-emulation-runtime/xr-session');
export class XRSession extends EventTarget {
    constructor(device, mode, enabledFeatures) {
        super();
        this[PRIVATE] = {
            device,
            mode,
            renderState: new XRRenderState(),
            pendingRenderState: null,
            enabledFeatures: enabledFeatures,
            isSystemKeyboardSupported: false,
            ended: false,
            projectionMatrices: {
                [XREye.Left]: mat4.create(),
                [XREye.Right]: mat4.create(),
                [XREye.None]: mat4.create(),
            },
            getProjectionMatrix: (eye) => {
                return this[PRIVATE].projectionMatrices[eye];
            },
            referenceSpaceIsSupported: (referenceSpaceType) => {
                if (!this[PRIVATE].enabledFeatures.includes(referenceSpaceType)) {
                    return false;
                }
                switch (referenceSpaceType) {
                    case XRReferenceSpaceType.Viewer:
                        return true;
                    case XRReferenceSpaceType.Local:
                    case XRReferenceSpaceType.LocalFloor:
                    case XRReferenceSpaceType.BoundedFloor:
                    case XRReferenceSpaceType.Unbounded:
                        return this[PRIVATE].mode != XRSessionMode.Inline;
                }
            },
            frameHandle: 0,
            frameCallbacks: [],
            currentFrameCallbacks: null,
            onDeviceFrame: () => {
                if (this[PRIVATE].ended) {
                    return;
                }
                this[PRIVATE].deviceFrameHandle = globalThis.requestAnimationFrame(this[PRIVATE].onDeviceFrame);
                if (this[PRIVATE].pendingRenderState != null) {
                    this[PRIVATE].renderState = this[PRIVATE].pendingRenderState;
                    this[PRIVATE].pendingRenderState = null;
                    this[PRIVATE].device[XRDEVICE_PRIVATE].onBaseLayerSet(this[PRIVATE].renderState.baseLayer);
                }
                const baseLayer = this[PRIVATE].renderState.baseLayer;
                if (baseLayer === null) {
                    return;
                }
                const context = baseLayer.context;
                const canvas = context.canvas;
                /**
                 * This code snippet is designed to clear the buffers attached to an opaque framebuffer
                 * at the beginning of each XR animation frame, but it only applies to immersive XR sessions.
                 * The process is as follows:
                 *
                 * 1. Check if the session is immersive: It verifies if `session.immersive` is true.
                 *    This ensures that the buffer clearing operations are only performed for immersive
                 *    sessions, which have exclusive access to the XR device's display.
                 *
                 * 2. Save current clear values: The current clear values for the color, depth, and
                 *    stencil buffers are stored. These values need to be restored after clearing the
                 *    buffers to maintain the application's rendering state as expected.
                 *
                 * 3. Set clear values to defaults: The clear color is set to transparent black, the
                 *    clear depth to the maximum depth value (1.0), and the clear stencil to 0. This
                 *    ensures that the buffers are reset to a known state, free from any residual data.
                 *
                 * 4. Clear the buffers: The depth, color, and stencil buffers are cleared, removing
                 *    any content from previous frames and preparing them for new rendering operations.
                 *
                 * 5. Restore previous clear values: The original clear values are reinstated to return
                 *    the WebGL context to its state prior to this operation, allowing subsequent rendering
                 *    to proceed without interference.
                 *
                 * This clearing process is crucial for some XR devices to function correctly and to
                 * prevent rendering artifacts from past frames. It ensures that each new frame starts
                 * with a clean slate.
                 */
                if (this[PRIVATE].mode != XRSessionMode.Inline) {
                    const currentClearColor = context.getParameter(context.COLOR_CLEAR_VALUE);
                    const currentClearDepth = context.getParameter(context.DEPTH_CLEAR_VALUE);
                    const currentClearStencil = context.getParameter(context.STENCIL_CLEAR_VALUE);
                    context.clearColor(0.0, 0.0, 0.0, 0.0);
                    context.clearDepth(1);
                    context.clearStencil(0.0);
                    context.clear(context.DEPTH_BUFFER_BIT |
                        context.COLOR_BUFFER_BIT |
                        context.STENCIL_BUFFER_BIT);
                    context.clearColor(currentClearColor[0], currentClearColor[1], currentClearColor[2], currentClearColor[3]);
                    context.clearDepth(currentClearDepth);
                    context.clearStencil(currentClearStencil);
                }
                // Calculate projection matrices
                const { depthNear, depthFar } = this[PRIVATE].renderState;
                const { width, height } = canvas;
                if (this[PRIVATE].mode !== XRSessionMode.Inline) {
                    const aspect = (width * (this[PRIVATE].device.stereoEnabled ? 0.5 : 1.0)) / height;
                    mat4.perspective(this[PRIVATE].projectionMatrices[XREye.Left], this[PRIVATE].device.fovy, aspect, depthNear, depthFar);
                    mat4.copy(this[PRIVATE].projectionMatrices[XREye.Right], this[PRIVATE].projectionMatrices[XREye.Left]);
                }
                else {
                    const aspect = width / height;
                    mat4.perspective(this[PRIVATE].projectionMatrices[XREye.None], this[PRIVATE].renderState.inlineVerticalFieldOfView, aspect, depthNear, depthFar);
                }
                const frame = new XRFrame(this, this[PRIVATE].frameHandle, true, true, performance.now());
                this[PRIVATE].device[XRDEVICE_PRIVATE].onFrameStart(frame);
                this[PRIVATE].updateActiveInputSources();
                /*
                 * For each entry in callbacks, in order:
                 * - If the entry’s cancelled boolean is true, continue to the next entry.
                 * - Invoke the Web IDL callback function, passing now and frame as the arguments.
                 * - If an exception is thrown, report the exception.
                 */
                // - Let callbacks be a list of the entries in session’s list of animation frame
                //   callback, in the order in which they were added to the list.
                const callbacks = (this[PRIVATE].currentFrameCallbacks =
                    this[PRIVATE].frameCallbacks);
                // - Set session’s list of animation frame callbacks to the empty list.
                this[PRIVATE].frameCallbacks = [];
                const rightNow = performance.now();
                for (let i = 0; i < callbacks.length; i++) {
                    try {
                        if (!callbacks[i].cancelled) {
                            callbacks[i].callback(rightNow, frame);
                        }
                    }
                    catch (err) {
                        console.error(err);
                    }
                }
                this[PRIVATE].currentFrameCallbacks = null;
                // - Set frame’s active boolean to false.
                frame[XRFRAME_PRIVATE].active = false;
            },
            nominalFrameRate: device.internalNominalFrameRate,
            referenceSpaces: [],
            inputSourceArray: [],
            activeInputSources: [],
            updateActiveInputSources: () => {
                const handTrackingOn = this[PRIVATE].enabledFeatures.includes(WebXRFeatures.HandTracking);
                const prevInputs = this[PRIVATE].activeInputSources;
                const currInputs = this[PRIVATE].device.inputSources.filter((inputSource) => !inputSource.hand || handTrackingOn);
                const added = currInputs.filter((item) => !prevInputs.includes(item));
                const removed = prevInputs.filter((item) => !currInputs.includes(item));
                this[PRIVATE].activeInputSources = currInputs;
                if (added.length > 0 || removed.length > 0) {
                    this.dispatchEvent(new XRInputSourcesChangeEvent('inputsourceschange', {
                        session: this,
                        added,
                        removed,
                    }));
                }
            },
            onend: null,
            oninputsourceschange: null,
            onselect: null,
            onselectstart: null,
            onselectend: null,
            onsqueeze: null,
            onsqueezestart: null,
            onsqueezeend: null,
            onvisibilitychange: null,
            onframeratechange: null,
        };
        // start the frameloop
        this[PRIVATE].onDeviceFrame();
    }
    get visibilityState() {
        return this[PRIVATE].device.visibilityState;
    }
    get frameRate() {
        return this[PRIVATE].nominalFrameRate;
    }
    get supportedFrameRates() {
        return new Float32Array(this[PRIVATE].device.supportedFrameRates);
    }
    get renderState() {
        return this[PRIVATE].renderState;
    }
    get inputSources() {
        // use the same array object
        this[PRIVATE].inputSourceArray.length = 0;
        if (!this[PRIVATE].ended && this[PRIVATE].mode !== XRSessionMode.Inline) {
            this[PRIVATE].inputSourceArray.push(...this[PRIVATE].activeInputSources);
        }
        return this[PRIVATE].inputSourceArray;
    }
    get enabledFeatures() {
        return this[PRIVATE].enabledFeatures;
    }
    get isSystemKeyboardSupported() {
        return this[PRIVATE].isSystemKeyboardSupported;
    }
    get environmentBlendMode() {
        var _a;
        return ((_a = this[PRIVATE].device[XRDEVICE_PRIVATE].environmentBlendModes[this[PRIVATE].mode]) !== null && _a !== void 0 ? _a : XREnvironmentBlendMode.Opaque);
    }
    get interactionMode() {
        return this[PRIVATE].device[XRDEVICE_PRIVATE].interactionMode;
    }
    updateRenderState(state = {}) {
        var _a, _b, _c, _d;
        if (this[PRIVATE].ended) {
            throw new DOMException('XRSession has already ended.', 'InvalidStateError');
        }
        if (state.baseLayer &&
            state.baseLayer[XRWEBGLLAYER_PRIVATE].session !== this) {
            throw new DOMException('Base layer was created by a different XRSession', 'InvalidStateError');
        }
        if (state.inlineVerticalFieldOfView != null &&
            this[PRIVATE].mode !== XRSessionMode.Inline) {
            throw new DOMException('InlineVerticalFieldOfView must not be set for an immersive session', 'InvalidStateError');
        }
        const compoundStateInit = {
            baseLayer: state.baseLayer ||
                ((_a = this[PRIVATE].pendingRenderState) === null || _a === void 0 ? void 0 : _a.baseLayer) ||
                undefined,
            depthFar: state.depthFar ||
                ((_b = this[PRIVATE].pendingRenderState) === null || _b === void 0 ? void 0 : _b.depthFar) ||
                undefined,
            depthNear: state.depthNear ||
                ((_c = this[PRIVATE].pendingRenderState) === null || _c === void 0 ? void 0 : _c.depthNear) ||
                undefined,
            inlineVerticalFieldOfView: state.inlineVerticalFieldOfView ||
                ((_d = this[PRIVATE].pendingRenderState) === null || _d === void 0 ? void 0 : _d.inlineVerticalFieldOfView) ||
                undefined,
        };
        this[PRIVATE].pendingRenderState = new XRRenderState(compoundStateInit, this[PRIVATE].renderState);
    }
    // the nominal frame rate updates are emulated, no actual update to the
    // display frame rate of the device will be executed
    async updateTargetFrameRate(rate) {
        return new Promise((resolve, reject) => {
            if (this[PRIVATE].ended) {
                reject(new DOMException('XRSession has already ended.', 'InvalidStateError'));
            }
            else if (!this[PRIVATE].device.supportedFrameRates.includes(rate)) {
                reject(new DOMException('Requested frame rate not supported.', 'InvalidStateError'));
            }
            else {
                if (this[PRIVATE].nominalFrameRate === rate) {
                    console.log(`Requested frame rate is the same as the current nominal frame rate, no update made`);
                }
                else {
                    this[PRIVATE].nominalFrameRate = rate;
                    this.dispatchEvent(new XRSessionEvent('frameratechange', { session: this }));
                    console.log(`Nominal frame rate updated to ${rate}`);
                }
                resolve();
            }
        });
    }
    async requestReferenceSpace(type) {
        return new Promise((resolve, reject) => {
            if (this[PRIVATE].ended ||
                !this[PRIVATE].referenceSpaceIsSupported(type)) {
                reject(new DOMException('The requested reference space type is not supported.', 'NotSupportedError'));
                return;
            }
            let referenceSpace;
            switch (type) {
                case XRReferenceSpaceType.Viewer:
                    referenceSpace = this[PRIVATE].device.viewerSpace;
                    break;
                case XRReferenceSpaceType.Local:
                    // creating an XRReferenceSpace with the current headset transform in global space
                    referenceSpace = new XRReferenceSpace(type, this[PRIVATE].device[XRDEVICE_PRIVATE].globalSpace, this[PRIVATE].device.viewerSpace[XRSPACE_PRIVATE].offsetMatrix);
                    break;
                case XRReferenceSpaceType.LocalFloor:
                case XRReferenceSpaceType.BoundedFloor:
                case XRReferenceSpaceType.Unbounded:
                    // TO-DO: add boundary geometry for bounded-floor
                    referenceSpace = new XRReferenceSpace(type, this[PRIVATE].device[XRDEVICE_PRIVATE].globalSpace);
                    break;
            }
            this[PRIVATE].referenceSpaces.push(referenceSpace);
            resolve(referenceSpace);
        });
    }
    requestAnimationFrame(callback) {
        if (this[PRIVATE].ended) {
            return 0;
        }
        const frameHandle = ++this[PRIVATE].frameHandle;
        this[PRIVATE].frameCallbacks.push({
            handle: frameHandle,
            callback,
            cancelled: false,
        });
        return frameHandle;
    }
    cancelAnimationFrame(handle) {
        // Remove the callback with that handle from the queue
        let callbacks = this[PRIVATE].frameCallbacks;
        let index = callbacks.findIndex((d) => d && d.handle === handle);
        if (index > -1) {
            callbacks[index].cancelled = true;
            callbacks.splice(index, 1);
        }
        // If cancelAnimationFrame is called from within a frame callback, also check
        // the remaining callbacks for the current frame:
        callbacks = this[PRIVATE].currentFrameCallbacks;
        if (callbacks) {
            index = callbacks.findIndex((d) => d && d.handle === handle);
            if (index > -1) {
                callbacks[index].cancelled = true;
                // Rely on cancelled flag only; don't mutate this array while it's being iterated
            }
        }
    }
    async end() {
        return new Promise((resolve, reject) => {
            if (this[PRIVATE].ended || this[PRIVATE].deviceFrameHandle === null) {
                reject(new DOMException('XRSession has already ended.', 'InvalidStateError'));
            }
            else {
                globalThis.cancelAnimationFrame(this[PRIVATE].deviceFrameHandle);
                this[PRIVATE].device[XRDEVICE_PRIVATE].onSessionEnd();
                this.dispatchEvent(new XRSessionEvent('end', { session: this }));
                resolve();
            }
        });
    }
    // events
    get onend() {
        var _a;
        return (_a = this[PRIVATE].onend) !== null && _a !== void 0 ? _a : (() => { });
    }
    set onend(callback) {
        if (this[PRIVATE].onend) {
            this.removeEventListener('end', this[PRIVATE].onend);
        }
        this[PRIVATE].onend = callback;
        if (callback) {
            this.addEventListener('end', callback);
        }
    }
    get oninputsourceschange() {
        var _a;
        return (_a = this[PRIVATE].oninputsourceschange) !== null && _a !== void 0 ? _a : (() => { });
    }
    set oninputsourceschange(callback) {
        if (this[PRIVATE].oninputsourceschange) {
            this.removeEventListener('inputsourceschange', this[PRIVATE].oninputsourceschange);
        }
        this[PRIVATE].oninputsourceschange = callback;
        if (callback) {
            this.addEventListener('inputsourceschange', callback);
        }
    }
    get onselect() {
        var _a;
        return (_a = this[PRIVATE].onselect) !== null && _a !== void 0 ? _a : (() => { });
    }
    set onselect(callback) {
        if (this[PRIVATE].onselect) {
            this.removeEventListener('select', this[PRIVATE].onselect);
        }
        this[PRIVATE].onselect = callback;
        if (callback) {
            this.addEventListener('select', callback);
        }
    }
    get onselectstart() {
        var _a;
        return (_a = this[PRIVATE].onselectstart) !== null && _a !== void 0 ? _a : (() => { });
    }
    set onselectstart(callback) {
        if (this[PRIVATE].onselectstart) {
            this.removeEventListener('selectstart', this[PRIVATE].onselectstart);
        }
        this[PRIVATE].onselectstart = callback;
        if (callback) {
            this.addEventListener('selectstart', callback);
        }
    }
    get onselectend() {
        var _a;
        return (_a = this[PRIVATE].onselectend) !== null && _a !== void 0 ? _a : (() => { });
    }
    set onselectend(callback) {
        if (this[PRIVATE].onselectend) {
            this.removeEventListener('selectend', this[PRIVATE].onselectend);
        }
        this[PRIVATE].onselectend = callback;
        if (callback) {
            this.addEventListener('selectend', callback);
        }
    }
    get onsqueeze() {
        var _a;
        return (_a = this[PRIVATE].onsqueeze) !== null && _a !== void 0 ? _a : (() => { });
    }
    set onsqueeze(callback) {
        if (this[PRIVATE].onsqueeze) {
            this.removeEventListener('squeeze', this[PRIVATE].onsqueeze);
        }
        this[PRIVATE].onsqueeze = callback;
        if (callback) {
            this.addEventListener('squeeze', callback);
        }
    }
    get onsqueezestart() {
        var _a;
        return (_a = this[PRIVATE].onsqueezestart) !== null && _a !== void 0 ? _a : (() => { });
    }
    set onsqueezestart(callback) {
        if (this[PRIVATE].onsqueezestart) {
            this.removeEventListener('squeezestart', this[PRIVATE].onsqueezestart);
        }
        this[PRIVATE].onsqueezestart = callback;
        if (callback) {
            this.addEventListener('squeezestart', callback);
        }
    }
    get onsqueezeend() {
        var _a;
        return (_a = this[PRIVATE].onsqueezeend) !== null && _a !== void 0 ? _a : (() => { });
    }
    set onsqueezeend(callback) {
        if (this[PRIVATE].onsqueezeend) {
            this.removeEventListener('squeezeend', this[PRIVATE].onsqueezeend);
        }
        this[PRIVATE].onsqueezeend = callback;
        if (callback) {
            this.addEventListener('squeezeend', callback);
        }
    }
    get onvisibilitychange() {
        var _a;
        return (_a = this[PRIVATE].onvisibilitychange) !== null && _a !== void 0 ? _a : (() => { });
    }
    set onvisibilitychange(callback) {
        if (this[PRIVATE].onvisibilitychange) {
            this.removeEventListener('visibilitychange', this[PRIVATE].onvisibilitychange);
        }
        this[PRIVATE].onvisibilitychange = callback;
        if (callback) {
            this.addEventListener('visibilitychange', callback);
        }
    }
    get onframeratechange() {
        var _a;
        return (_a = this[PRIVATE].onframeratechange) !== null && _a !== void 0 ? _a : (() => { });
    }
    set onframeratechange(callback) {
        if (this[PRIVATE].onframeratechange) {
            this.removeEventListener('frameratechange', this[PRIVATE].onframeratechange);
        }
        this[PRIVATE].onframeratechange = callback;
        if (callback) {
            this.addEventListener('frameratechange', callback);
        }
    }
}
//# sourceMappingURL=XRSession.js.map