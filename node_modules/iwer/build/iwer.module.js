/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create$4() {
  var out = new ARRAY_TYPE(9);

  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create$3() {
  var out = new ARRAY_TYPE(16);

  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function copy$3(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function multiply$1(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Alias for {@link mat4.perspectiveNO}
 * @function
 */

var perspective = perspectiveNO;

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create$2() {
  var out = new ARRAY_TYPE(3);

  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues$2(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */

function copy$2(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set$2(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize$2(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

(function () {
  var vec = create$2();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
})();

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create$1() {
  var out = new ARRAY_TYPE(4);

  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues$1(x, y, z, w) {
  var out = new ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */

function copy$1(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set$1(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize$1(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

(function () {
  var vec = create$1();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
})();

/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create() {
  var out = new ARRAY_TYPE(4);

  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 */

function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate conjugate of
 * @returns {quat} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

var fromValues = fromValues$1;
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the source quaternion
 * @returns {quat} out
 * @function
 */

var copy = copy$1;
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

var set = set$1;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize = normalize$1;
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */

(function () {
  var tmpvec3 = create$2();
  var xUnitVec3 = fromValues$2(1, 0, 0);
  var yUnitVec3 = fromValues$2(0, 1, 0);
  return function (out, a, b) {
    var dot$1 = dot(a, b);

    if (dot$1 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 0.000001) cross(tmpvec3, yUnitVec3, a);
      normalize$2(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot$1 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot$1;
      return normalize(out, out);
    }
  };
})();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

(function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
})();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

(function () {
  var matr = create$4();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
})();

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const PRIVATE$l = Symbol('@immersive-web-emulation-runtime/xr-space');
class XRSpace extends EventTarget {
    constructor(parentSpace, offsetMatrix) {
        super();
        this[PRIVATE$l] = {
            parentSpace,
            offsetMatrix: offsetMatrix ? clone(offsetMatrix) : create$3(),
            emulated: true,
        };
    }
}
class GlobalSpace extends XRSpace {
    constructor() {
        super(undefined, create$3()); // GlobalSpace has no parent
    }
}
class XRSpaceUtils {
    // Update the position component of the offsetMatrix of a given XRSpace
    static updateOffsetPosition(space, position) {
        const offsetMatrix = space[PRIVATE$l].offsetMatrix;
        fromTranslation(offsetMatrix, position);
    }
    // Update the rotation component of the offsetMatrix of a given XRSpace using a quaternion
    static updateOffsetQuaternion(space, quaternion) {
        const offsetMatrix = space[PRIVATE$l].offsetMatrix;
        const translation = create$2();
        getTranslation(translation, offsetMatrix);
        fromRotationTranslation(offsetMatrix, quaternion, translation);
    }
    // Update the offsetMatrix of a given XRSpace directly
    static updateOffsetMatrix(space, matrix) {
        const offsetMatrix = space[PRIVATE$l].offsetMatrix;
        copy$3(offsetMatrix, matrix);
    }
    // Calculate the global offset matrix for a given XRSpace
    static calculateGlobalOffsetMatrix(space, globalOffset = create$3()) {
        const parentOffset = space[PRIVATE$l].parentSpace
            ? XRSpaceUtils.calculateGlobalOffsetMatrix(space[PRIVATE$l].parentSpace)
            : create$3(); // Identity matrix for GlobalSpace
        multiply$1(globalOffset, parentOffset, space[PRIVATE$l].offsetMatrix);
        return globalOffset;
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Wrapper class for gl-matrix vec3
 * Minimal interoperable interface to Vector3 in Three.js and Babylon.js
 */
class Vector3 {
    constructor(x = 0, y = 0, z = 0) {
        this.vec3 = fromValues$2(x, y, z);
        this.tempVec3 = create$2();
    }
    get x() {
        return this.vec3[0];
    }
    set x(value) {
        this.vec3[0] = value;
    }
    get y() {
        return this.vec3[1];
    }
    set y(value) {
        this.vec3[1] = value;
    }
    get z() {
        return this.vec3[2];
    }
    set z(value) {
        this.vec3[2] = value;
    }
    set(x, y, z) {
        set$2(this.vec3, x, y, z);
        return this;
    }
    clone() {
        return new Vector3(this.x, this.y, this.z);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
    }
    normalize() {
        copy$2(this.tempVec3, this.vec3);
        normalize$2(this.vec3, this.tempVec3);
        return this;
    }
    add(v) {
        copy$2(this.tempVec3, this.vec3);
        add(this.vec3, this.tempVec3, v.vec3);
        return this;
    }
    applyQuaternion(q) {
        copy$2(this.tempVec3, this.vec3);
        transformQuat(this.vec3, this.tempVec3, q.quat);
        return this;
    }
}
/**
 * Wrapper class for gl-matrix quat4
 * Minimal interoperable interface to Vector3 in Three.js and Babylon.js
 */
class Quaternion {
    constructor(x = 0, y = 0, z = 0, w = 1) {
        this.quat = fromValues(x, y, z, w);
        this.tempQuat = create();
    }
    get x() {
        return this.quat[0];
    }
    set x(value) {
        this.quat[0] = value;
    }
    get y() {
        return this.quat[1];
    }
    set y(value) {
        this.quat[1] = value;
    }
    get z() {
        return this.quat[2];
    }
    set z(value) {
        this.quat[2] = value;
    }
    get w() {
        return this.quat[3];
    }
    set w(value) {
        this.quat[3] = value;
    }
    set(x, y, z, w) {
        set(this.quat, x, y, z, w);
        return this;
    }
    clone() {
        return new Quaternion(this.x, this.y, this.z, this.w);
    }
    copy(q) {
        set(this.quat, q.x, q.y, q.z, q.w);
        return this;
    }
    normalize() {
        copy(this.tempQuat, this.quat);
        normalize(this.quat, this.tempQuat);
        return this;
    }
    invert() {
        copy(this.tempQuat, this.quat);
        conjugate(this.quat, this.tempQuat);
        return this;
    }
    multiply(q) {
        copy(this.tempQuat, this.quat);
        multiply(this.quat, this.tempQuat, q.quat);
        return this;
    }
    setFromAxisAngle(axis, angle) {
        setAxisAngle(this.quat, axis.vec3, angle);
        return this;
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const PRIVATE$k = Symbol('@immersive-web-emulation-runtime/gamepad');
var GamepadMappingType;
(function (GamepadMappingType) {
    GamepadMappingType["None"] = "";
    GamepadMappingType["Standard"] = "standard";
    GamepadMappingType["XRStandard"] = "xr-standard";
})(GamepadMappingType || (GamepadMappingType = {}));
class GamepadButton {
    constructor(type, eventTrigger) {
        this[PRIVATE$k] = {
            type,
            eventTrigger,
            pressed: false,
            touched: false,
            value: 0,
            lastFrameValue: 0,
            pendingValue: null,
        };
    }
    get pressed() {
        if (this[PRIVATE$k].type === 'manual') {
            return this[PRIVATE$k].pressed;
        }
        else {
            return this[PRIVATE$k].value > 0;
        }
    }
    get touched() {
        if (this[PRIVATE$k].type === 'manual') {
            return this[PRIVATE$k].touched;
        }
        else {
            return this[PRIVATE$k].touched || this.pressed;
        }
    }
    get value() {
        return this[PRIVATE$k].value;
    }
}
class EmptyGamepadButton {
    constructor() {
        this.pressed = false;
        this.touched = false;
        this.value = 0;
    }
}
class Gamepad {
    constructor(gamepadConfig, id = '', index = -1) {
        this[PRIVATE$k] = {
            id,
            index,
            connected: false,
            timestamp: performance.now(),
            mapping: gamepadConfig.mapping,
            buttonsMap: {},
            buttonsSequence: [],
            axesMap: {},
            axesSequence: [],
            hapticActuators: [],
        };
        gamepadConfig.buttons.forEach((buttonConfig) => {
            var _a;
            if (buttonConfig === null) {
                this[PRIVATE$k].buttonsSequence.push(null);
            }
            else {
                this[PRIVATE$k].buttonsSequence.push(buttonConfig.id);
                this[PRIVATE$k].buttonsMap[buttonConfig.id] = new GamepadButton(buttonConfig.type, (_a = buttonConfig.eventTrigger) !== null && _a !== void 0 ? _a : null);
            }
        });
        gamepadConfig.axes.forEach((axisConfig) => {
            if (axisConfig === null) {
                this[PRIVATE$k].axesSequence.push(null);
            }
            else {
                this[PRIVATE$k].axesSequence.push(axisConfig.id + axisConfig.type);
                if (!this[PRIVATE$k].axesMap[axisConfig.id]) {
                    this[PRIVATE$k].axesMap[axisConfig.id] = { x: 0, y: 0 };
                }
            }
        });
    }
    get id() {
        return this[PRIVATE$k].id;
    }
    get index() {
        return this[PRIVATE$k].index;
    }
    get connected() {
        return this[PRIVATE$k].connected;
    }
    get timestamp() {
        return this[PRIVATE$k].timestamp;
    }
    get mapping() {
        return this[PRIVATE$k].mapping;
    }
    get axes() {
        const axes = [];
        this[PRIVATE$k].axesSequence.forEach((id) => {
            if (id === null) {
                axes.push(null);
            }
            else {
                const axisId = id.substring(0, id.length - 6);
                const axisType = id.substring(id.length - 6);
                axes.push(
                // if axis type is manual, then return the x value
                axisType === 'y-axis'
                    ? this[PRIVATE$k].axesMap[axisId].y
                    : this[PRIVATE$k].axesMap[axisId].x);
            }
        });
        return axes;
    }
    get buttons() {
        return this[PRIVATE$k].buttonsSequence.map((id) => id === null ? new EmptyGamepadButton() : this[PRIVATE$k].buttonsMap[id]);
    }
    get hapticActuators() {
        return this[PRIVATE$k].hapticActuators;
    }
    get vibrationActuator() {
        return null;
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var XRHandedness;
(function (XRHandedness) {
    XRHandedness["None"] = "none";
    XRHandedness["Left"] = "left";
    XRHandedness["Right"] = "right";
})(XRHandedness || (XRHandedness = {}));
var XRTargetRayMode;
(function (XRTargetRayMode) {
    XRTargetRayMode["Gaze"] = "gaze";
    XRTargetRayMode["TrackedPointer"] = "tracked-pointer";
    XRTargetRayMode["Screen"] = "screen";
    XRTargetRayMode["TransientPointer"] = "transient-pointer";
})(XRTargetRayMode || (XRTargetRayMode = {}));
class XRInputSourceArray extends Array {
}
const PRIVATE$j = Symbol('@immersive-web-emulation-runtime/xr-input-source');
class XRInputSource {
    constructor(handedness, targetRayMode, profiles, targetRaySpace, gamepad, gripSpace, hand) {
        this[PRIVATE$j] = {
            handedness,
            targetRayMode,
            targetRaySpace,
            gripSpace,
            profiles,
            gamepad,
            hand,
        };
    }
    get handedness() {
        return this[PRIVATE$j].handedness;
    }
    get targetRayMode() {
        return this[PRIVATE$j].targetRayMode;
    }
    get targetRaySpace() {
        return this[PRIVATE$j].targetRaySpace;
    }
    get gripSpace() {
        return this[PRIVATE$j].gripSpace;
    }
    get profiles() {
        return this[PRIVATE$j].profiles;
    }
    get gamepad() {
        return this[PRIVATE$j].gamepad;
    }
    get hand() {
        return this[PRIVATE$j].hand;
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
class XRInputSourceEvent extends Event {
    constructor(type, eventInitDict) {
        super(type, eventInitDict);
        if (!eventInitDict.frame) {
            throw new Error('XRInputSourceEventInit.frame is required');
        }
        if (!eventInitDict.inputSource) {
            throw new Error('XRInputSourceEventInit.inputSource is required');
        }
        this.frame = eventInitDict.frame;
        this.inputSource = eventInitDict.inputSource;
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const PRIVATE$i = Symbol('@immersive-web-emulation-runtime/xr-tracked-input');
const DEFAULT_TRANSFORM = {
    [XRHandedness.Left]: {
        position: new Vector3(-0.25, 1.5, -0.4),
        quaternion: new Quaternion(),
    },
    [XRHandedness.Right]: {
        position: new Vector3(0.25, 1.5, -0.4),
        quaternion: new Quaternion(),
    },
    [XRHandedness.None]: {
        position: new Vector3(0.25, 1.5, -0.4),
        quaternion: new Quaternion(),
    },
};
class XRTrackedInput {
    constructor(inputSource) {
        this[PRIVATE$i] = {
            inputSource,
            position: DEFAULT_TRANSFORM[inputSource.handedness].position.clone(),
            quaternion: DEFAULT_TRANSFORM[inputSource.handedness].quaternion.clone(),
            connected: true,
            lastFrameConnected: false,
            inputSourceChanged: true,
        };
    }
    get position() {
        return this[PRIVATE$i].position;
    }
    get quaternion() {
        return this[PRIVATE$i].quaternion;
    }
    get inputSource() {
        return this[PRIVATE$i].inputSource;
    }
    get connected() {
        return this[PRIVATE$i].connected;
    }
    set connected(value) {
        this[PRIVATE$i].connected = value;
        this[PRIVATE$i].inputSource.gamepad[PRIVATE$k].connected = value;
    }
    onFrameStart(frame) {
        const targetRaySpace = this[PRIVATE$i].inputSource.targetRaySpace;
        fromRotationTranslation(targetRaySpace[PRIVATE$l].offsetMatrix, this[PRIVATE$i].quaternion.quat, this[PRIVATE$i].position.vec3);
        const session = frame.session;
        this[PRIVATE$i].inputSource.gamepad.buttons.forEach((button) => {
            if (button instanceof GamepadButton) {
                // apply pending values and record last frame values
                button[PRIVATE$k].lastFrameValue = button[PRIVATE$k].value;
                if (button[PRIVATE$k].pendingValue != null) {
                    button[PRIVATE$k].value = button[PRIVATE$k].pendingValue;
                    button[PRIVATE$k].pendingValue = null;
                }
                // trigger input source events
                if (button[PRIVATE$k].eventTrigger != null) {
                    if (button[PRIVATE$k].lastFrameValue === 0 &&
                        button[PRIVATE$k].value > 0) {
                        session.dispatchEvent(new XRInputSourceEvent(button[PRIVATE$k].eventTrigger, {
                            frame,
                            inputSource: this[PRIVATE$i].inputSource,
                        }));
                        session.dispatchEvent(new XRInputSourceEvent(button[PRIVATE$k].eventTrigger + 'start', {
                            frame,
                            inputSource: this[PRIVATE$i].inputSource,
                        }));
                    }
                    else if (button[PRIVATE$k].lastFrameValue > 0 &&
                        button[PRIVATE$k].value === 0) {
                        session.dispatchEvent(new XRInputSourceEvent(button[PRIVATE$k].eventTrigger + 'end', {
                            frame,
                            inputSource: this[PRIVATE$i].inputSource,
                        }));
                    }
                }
            }
        });
        this[PRIVATE$i].inputSourceChanged =
            this.connected !== this[PRIVATE$i].lastFrameConnected;
        this[PRIVATE$i].lastFrameConnected = this.connected;
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const PRIVATE$h = Symbol('@immersive-web-emulation-runtime/xr-controller');
class XRController extends XRTrackedInput {
    constructor(controllerConfig, handedness, globalSpace) {
        if (!controllerConfig.layout[handedness]) {
            throw new DOMException('Handedness not supported', 'InvalidStateError');
        }
        const targetRaySpace = new XRSpace(globalSpace);
        const gripSpace = controllerConfig.layout[handedness].gripOffsetMatrix
            ? new XRSpace(targetRaySpace, controllerConfig.layout[handedness].gripOffsetMatrix)
            : undefined;
        const profiles = [
            controllerConfig.profileId,
            ...controllerConfig.fallbackProfileIds,
        ];
        const inputSource = new XRInputSource(handedness, XRTargetRayMode.TrackedPointer, profiles, targetRaySpace, new Gamepad(controllerConfig.layout[handedness].gamepad), gripSpace);
        super(inputSource);
        this[PRIVATE$h] = {
            gamepadConfig: controllerConfig.layout[handedness].gamepad,
        };
    }
    get gamepadConfig() {
        return this[PRIVATE$h].gamepadConfig;
    }
    updateButtonValue(id, value) {
        if (value > 1 || value < 0) {
            console.warn(`Out-of-range value ${value} provided for button ${id}.`);
            return;
        }
        const gamepadButton = this[PRIVATE$i].inputSource.gamepad[PRIVATE$k]
            .buttonsMap[id];
        if (gamepadButton) {
            if (gamepadButton[PRIVATE$k].type === 'binary' &&
                value != 1 &&
                value != 0) {
                console.warn(`Non-binary value ${value} provided for binary button ${id}.`);
                return;
            }
            gamepadButton[PRIVATE$k].pendingValue = value;
        }
        else {
            console.warn(`Current controller does not have button ${id}.`);
        }
    }
    updateButtonTouch(id, touched) {
        const gamepadButton = this[PRIVATE$i].inputSource.gamepad[PRIVATE$k]
            .buttonsMap[id];
        if (gamepadButton) {
            gamepadButton[PRIVATE$k].touched = touched;
        }
        else {
            console.warn(`Current controller does not have button ${id}.`);
        }
    }
    updateAxis(id, type, value) {
        if (value > 1 || value < -1) {
            console.warn(`Out-of-range value ${value} provided for ${id} axes.`);
            return;
        }
        const axesById = this[PRIVATE$i].inputSource.gamepad[PRIVATE$k]
            .axesMap[id];
        if (axesById) {
            if (type === 'x-axis') {
                axesById.x = value;
            }
            else if (type === 'y-axis') {
                axesById.y = value;
            }
        }
        else {
            console.warn(`Current controller does not have ${id} axes.`);
        }
    }
    updateAxes(id, x, y) {
        if (x > 1 || x < -1 || y > 1 || y < -1) {
            console.warn(`Out-of-range value x:${x}, y:${y} provided for ${id} axes.`);
            return;
        }
        const axesById = this[PRIVATE$i].inputSource.gamepad[PRIVATE$k]
            .axesMap[id];
        if (axesById) {
            axesById.x = x;
            axesById.y = y;
        }
        else {
            console.warn(`Current controller does not have ${id} axes.`);
        }
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const PRIVATE$g = Symbol('@immersive-web-emulation-runtime/xr-view');
var XREye;
(function (XREye) {
    XREye["None"] = "none";
    XREye["Left"] = "left";
    XREye["Right"] = "right";
})(XREye || (XREye = {}));
class XRView {
    constructor(eye, projectionMatrix, transform, session) {
        this[PRIVATE$g] = {
            eye,
            projectionMatrix,
            transform,
            recommendedViewportScale: null,
            requestedViewportScale: 1.0,
            session,
        };
    }
    get eye() {
        return this[PRIVATE$g].eye;
    }
    get projectionMatrix() {
        return this[PRIVATE$g].projectionMatrix;
    }
    get transform() {
        return this[PRIVATE$g].transform;
    }
    get recommendedViewportScale() {
        return this[PRIVATE$g].recommendedViewportScale;
    }
    requestViewportScale(scale) {
        if (scale === null || scale <= 0 || scale > 1) {
            console.warn('Invalid scale value. Scale must be > 0 and <= 1.');
            return;
        }
        this[PRIVATE$g].requestedViewportScale = scale;
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const PRIVATE$f = Symbol('@immersive-web-emulation-runtime/xr-joint-space');
class XRJointSpace extends XRSpace {
    constructor(jointName, parentSpace, offsetMatrix) {
        super(parentSpace, offsetMatrix);
        this[PRIVATE$f] = { jointName, radius: 0 };
    }
    get jointName() {
        return this[PRIVATE$f].jointName;
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const PRIVATE$e = Symbol('@immersive-web-emulation-runtime/xr-pose');
class XRPose {
    constructor(transform, emulatedPosition = false, linearVelocity = undefined, angularVelocity = undefined) {
        this[PRIVATE$e] = {
            transform,
            emulatedPosition,
            linearVelocity,
            angularVelocity,
        };
    }
    get transform() {
        return this[PRIVATE$e].transform;
    }
    get emulatedPosition() {
        return this[PRIVATE$e].emulatedPosition;
    }
    get linearVelocity() {
        return this[PRIVATE$e].linearVelocity;
    }
    get angularVelocity() {
        return this[PRIVATE$e].angularVelocity;
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const PRIVATE$d = Symbol('@immersive-web-emulation-runtime/xr-joint-pose');
class XRJointPose extends XRPose {
    constructor(transform, radius, emulatedPosition = false, linearVelocity = undefined, angularVelocity = undefined) {
        super(transform, emulatedPosition, linearVelocity, angularVelocity);
        this[PRIVATE$d] = { radius };
    }
    get radius() {
        return this[PRIVATE$d].radius;
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
class PolyfillDOMPointReadOnly {
    constructor(x = 0, y = 0, z = 0, w = 1) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        Object.freeze(this);
    }
    static fromPoint(other) {
        return new PolyfillDOMPointReadOnly(other.x, other.y, other.z, other.w);
    }
    matrixTransform(_matrix) {
        // Implement matrix transformation logic here
        // This is a placeholder implementation
        return new PolyfillDOMPointReadOnly();
    }
    toJSON() {
        // Implement toJSON logic here
        // This is a placeholder implementation
        return { x: this.x, y: this.y, z: this.z, w: this.w };
    }
}
const DOMPointReadOnly = typeof globalThis.DOMPointReadOnly !== 'undefined'
    ? globalThis.DOMPointReadOnly
    : PolyfillDOMPointReadOnly;

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const PRIVATE$c = Symbol('@immersive-web-emulation-runtime/xr-rigid-transform');
class XRRigidTransform {
    constructor(position, orientation) {
        // Default values
        const defaultPosition = fromValues$2(0, 0, 0);
        const defaultOrientation = create();
        this[PRIVATE$c] = {
            matrix: create$3(),
            position: position
                ? fromValues$2(position.x, position.y, position.z)
                : defaultPosition,
            orientation: orientation
                ? normalize(create(), fromValues(orientation.x, orientation.y, orientation.z, orientation.w))
                : defaultOrientation,
            inverse: null,
        };
        this.updateMatrix();
    }
    updateMatrix() {
        fromRotationTranslation(this[PRIVATE$c].matrix, this[PRIVATE$c].orientation, this[PRIVATE$c].position);
    }
    get matrix() {
        return this[PRIVATE$c].matrix;
    }
    get position() {
        const pos = this[PRIVATE$c].position;
        return new DOMPointReadOnly(pos[0], pos[1], pos[2], 1);
    }
    get orientation() {
        const ori = this[PRIVATE$c].orientation;
        return new DOMPointReadOnly(ori[0], ori[1], ori[2], ori[3]);
    }
    get inverse() {
        if (!this[PRIVATE$c].inverse) {
            const invMatrix = create$3();
            if (!invert(invMatrix, this[PRIVATE$c].matrix)) {
                throw new Error('Matrix is not invertible.');
            }
            // Decomposing the inverse matrix into position and orientation
            let invPosition = create$2();
            getTranslation(invPosition, invMatrix);
            let invOrientation = create();
            getRotation(invOrientation, invMatrix);
            // Creating a new XRRigidTransform for the inverse
            this[PRIVATE$c].inverse = new XRRigidTransform(new DOMPointReadOnly(invPosition[0], invPosition[1], invPosition[2], 1), new DOMPointReadOnly(invOrientation[0], invOrientation[1], invOrientation[2], invOrientation[3]));
            // Setting the inverse of the inverse to be this transform
            this[PRIVATE$c].inverse[PRIVATE$c].inverse = this;
        }
        return this[PRIVATE$c].inverse;
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const PRIVATE$b = Symbol('@immersive-web-emulation-runtime/xr-viewer-pose');
class XRViewerPose extends XRPose {
    constructor(transform, views, emulatedPosition = false, linearVelocity = undefined, angularVelocity = undefined) {
        super(transform, emulatedPosition, linearVelocity, angularVelocity);
        this[PRIVATE$b] = {
            views: Object.freeze(views),
        };
    }
    get views() {
        return this[PRIVATE$b].views;
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const PRIVATE$a = Symbol('@immersive-web-emulation-runtime/xr-frame');
const spaceGlobalMatrix = create$3();
const baseSpaceGlobalMatrix = create$3();
const baseSpaceGlobalMatrixInverse = create$3();
const getOffsetMatrix = (offsetMatrix, space, baseSpace) => {
    XRSpaceUtils.calculateGlobalOffsetMatrix(space, spaceGlobalMatrix);
    XRSpaceUtils.calculateGlobalOffsetMatrix(baseSpace, baseSpaceGlobalMatrix);
    invert(baseSpaceGlobalMatrixInverse, baseSpaceGlobalMatrix);
    multiply$1(offsetMatrix, baseSpaceGlobalMatrixInverse, spaceGlobalMatrix);
};
class XRFrame {
    constructor(session, id, active, animationFrame, predictedDisplayTime) {
        this[PRIVATE$a] = {
            session,
            id,
            active,
            animationFrame,
            predictedDisplayTime,
            tempMat4: create$3(),
        };
    }
    get session() {
        return this[PRIVATE$a].session;
    }
    get predictedDisplayTime() {
        return this[PRIVATE$a].predictedDisplayTime;
    }
    getPose(space, baseSpace) {
        if (!this[PRIVATE$a].active) {
            throw new DOMException('XRFrame access outside the callback that produced it is invalid.', 'InvalidStateError');
        }
        getOffsetMatrix(this[PRIVATE$a].tempMat4, space, baseSpace);
        const position = create$2();
        getTranslation(position, this[PRIVATE$a].tempMat4);
        const orientation = create();
        getRotation(orientation, this[PRIVATE$a].tempMat4);
        return new XRPose(new XRRigidTransform({ x: position[0], y: position[1], z: position[2], w: 1.0 }, {
            x: orientation[0],
            y: orientation[1],
            z: orientation[2],
            w: orientation[3],
        }), space[PRIVATE$l].emulated);
    }
    getViewerPose(referenceSpace) {
        if (!this[PRIVATE$a].animationFrame) {
            throw new DOMException('getViewerPose can only be called on XRFrame objects passed to XRSession.requestAnimationFrame callbacks.', 'InvalidStateError');
        }
        const session = this[PRIVATE$a].session;
        const device = session[PRIVATE$6].device;
        const pose = this.getPose(device.viewerSpace, referenceSpace);
        const eyes = session[PRIVATE$6].mode === XRSessionMode.Inline
            ? [XREye.None]
            : [XREye.Left, XREye.Right];
        const views = [];
        eyes.forEach((eye) => {
            const viewSpace = device.viewSpaces[eye];
            const viewPose = this.getPose(viewSpace, referenceSpace);
            const projectionMatrix = session[PRIVATE$6].getProjectionMatrix(eye);
            const view = new XRView(eye, new Float32Array(projectionMatrix), viewPose.transform, session);
            views.push(view);
        });
        return new XRViewerPose(pose.transform, views, false);
    }
    getJointPose(joint, baseSpace) {
        const xrPose = this.getPose(joint, baseSpace);
        const radius = joint[PRIVATE$f].radius;
        return new XRJointPose(xrPose.transform, radius, false);
    }
    fillJointRadii(jointSpaces, radii) {
        // converting from sequence type to array
        jointSpaces = Array.from(jointSpaces);
        if (!this[PRIVATE$a].active) {
            throw new DOMException('XRFrame access outside the callback that produced it is invalid.', 'InvalidStateError');
        }
        if (jointSpaces.length > radii.length) {
            throw new DOMException('The length of jointSpaces is larger than the number of elements in radii', 'TypeError');
        }
        let allValid = true;
        for (let offset = 0; offset < jointSpaces.length; offset++) {
            if (!jointSpaces[offset][PRIVATE$f].radius) {
                radii[offset] = NaN;
                allValid = false;
            }
            else {
                radii[offset] = jointSpaces[offset][PRIVATE$f].radius;
            }
        }
        return allValid;
    }
    fillPoses(spaces, baseSpace, transforms) {
        // converting from sequence type to array
        spaces = Array.from(spaces);
        if (!this[PRIVATE$a].active) {
            throw new DOMException('XRFrame access outside the callback that produced it is invalid.', 'InvalidStateError');
        }
        if (spaces.length * 16 > transforms.length) {
            throw new DOMException('The length of spaces multiplied by 16 is larger than the number of elements in transforms', 'TypeError');
        }
        spaces.forEach((space, i) => {
            getOffsetMatrix(this[PRIVATE$a].tempMat4, space, baseSpace);
            for (let j = 0; j < 16; j++) {
                transforms[i * 16 + j] = this[PRIVATE$a].tempMat4[j];
            }
        });
        return true;
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
class XRInputSourcesChangeEvent extends Event {
    constructor(type, eventInitDict) {
        super(type, eventInitDict);
        if (!eventInitDict.session) {
            throw new Error('XRInputSourcesChangeEventInit.session is required');
        }
        if (!eventInitDict.added) {
            throw new Error('XRInputSourcesChangeEventInit.added is required');
        }
        if (!eventInitDict.removed) {
            throw new Error('XRInputSourcesChangeEventInit.removed is required');
        }
        this.session = eventInitDict.session;
        this.added = eventInitDict.added;
        this.removed = eventInitDict.removed;
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var _a;
const PRIVATE$9 = Symbol('@immersive-web-emulation-runtime/xr-reference-space');
var XRReferenceSpaceType;
(function (XRReferenceSpaceType) {
    XRReferenceSpaceType["Viewer"] = "viewer";
    XRReferenceSpaceType["Local"] = "local";
    XRReferenceSpaceType["LocalFloor"] = "local-floor";
    XRReferenceSpaceType["BoundedFloor"] = "bounded-floor";
    XRReferenceSpaceType["Unbounded"] = "unbounded";
})(XRReferenceSpaceType || (XRReferenceSpaceType = {}));
class XRReferenceSpace extends XRSpace {
    constructor(type, parentSpace, offsetMatrix) {
        super(parentSpace, offsetMatrix);
        this[_a] = {
            type: null,
            onreset: () => { },
        };
        this[PRIVATE$9].type = type;
    }
    get onreset() {
        var _b;
        return (_b = this[PRIVATE$9].onreset) !== null && _b !== void 0 ? _b : (() => { });
    }
    set onreset(callback) {
        if (this[PRIVATE$9].onreset) {
            this.removeEventListener('reset', this[PRIVATE$9].onreset);
        }
        this[PRIVATE$9].onreset = callback;
        if (callback) {
            this.addEventListener('reset', callback);
        }
    }
    // Create a new XRReferenceSpace with an offset from the current space
    getOffsetReferenceSpace(originOffset) {
        // Create a new XRReferenceSpace with the originOffset as its offsetMatrix
        // The new space's parent is set to 'this' (the current XRReferenceSpace)
        return new XRReferenceSpace(this[PRIVATE$9].type, this, originOffset);
    }
}
_a = PRIVATE$9;

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const PRIVATE$8 = Symbol('@immersive-web-emulation-runtime/xr-render-state');
class XRRenderState {
    constructor(init = {}, oldState) {
        this[PRIVATE$8] = {
            depthNear: init.depthNear || (oldState === null || oldState === void 0 ? void 0 : oldState.depthNear) || 0.1,
            depthFar: init.depthFar || (oldState === null || oldState === void 0 ? void 0 : oldState.depthFar) || 1000.0,
            inlineVerticalFieldOfView: init.inlineVerticalFieldOfView ||
                (oldState === null || oldState === void 0 ? void 0 : oldState.inlineVerticalFieldOfView) ||
                null,
            baseLayer: init.baseLayer || (oldState === null || oldState === void 0 ? void 0 : oldState.baseLayer) || null,
        };
    }
    get depthNear() {
        return this[PRIVATE$8].depthNear;
    }
    get depthFar() {
        return this[PRIVATE$8].depthFar;
    }
    get inlineVerticalFieldOfView() {
        return this[PRIVATE$8].inlineVerticalFieldOfView;
    }
    get baseLayer() {
        return this[PRIVATE$8].baseLayer;
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
class XRSessionEvent extends Event {
    constructor(type, eventInitDict) {
        super(type, eventInitDict);
        if (!eventInitDict.session) {
            throw new Error('XRSessionEventInit.session is required');
        }
        this.session = eventInitDict.session;
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
class XRLayer extends EventTarget {
}
const PRIVATE$7 = Symbol('@immersive-web-emulation-runtime/XRWebGLLayer');
const defaultLayerInit = {
    antialias: true,
    depth: true,
    stencil: false,
    alpha: true,
    ignoreDepthValues: false,
    framebufferScaleFactor: 1.0,
};
class XRWebGLLayer extends XRLayer {
    constructor(session, context, layerInit = {}) {
        super();
        if (session[PRIVATE$6].ended) {
            throw new DOMException('Session has ended', 'InvalidStateError');
        }
        // TO-DO: Check that the context attribute has xrCompatible set to true
        // may require polyfilling the context and perhaps canvas.getContext
        // Default values for XRWebGLLayerInit, can be overridden by layerInit
        const config = { ...defaultLayerInit, ...layerInit };
        this[PRIVATE$7] = {
            session,
            context,
            antialias: config.antialias,
        };
    }
    get context() {
        return this[PRIVATE$7].context;
    }
    get antialias() {
        return this[PRIVATE$7].antialias;
    }
    get ignoreDepthValues() {
        return true;
    }
    get framebuffer() {
        return null;
    }
    get framebufferWidth() {
        return this[PRIVATE$7].context.drawingBufferWidth;
    }
    get framebufferHeight() {
        return this[PRIVATE$7].context.drawingBufferHeight;
    }
    getViewport(view) {
        if (view[PRIVATE$g].session !== this[PRIVATE$7].session) {
            throw new DOMException("View's session differs from Layer's session", 'InvalidStateError');
        }
        // TO-DO: check frame
        return this[PRIVATE$7].session[PRIVATE$6].device[PRIVATE$1].getViewport(this, view);
    }
    static getNativeFramebufferScaleFactor(session) {
        if (!(session instanceof XRSession)) {
            throw new TypeError('getNativeFramebufferScaleFactor must be passed a session.');
        }
        if (session[PRIVATE$6].ended) {
            return 0.0;
        }
        // Return 1.0 for simplicity, actual implementation might vary based on the device capabilities
        return 1.0;
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var XRVisibilityState;
(function (XRVisibilityState) {
    XRVisibilityState["Visible"] = "visible";
    XRVisibilityState["VisibleBlurred"] = "visible-blurred";
    XRVisibilityState["Hidden"] = "hidden";
})(XRVisibilityState || (XRVisibilityState = {}));
var XRSessionMode;
(function (XRSessionMode) {
    XRSessionMode["Inline"] = "inline";
    XRSessionMode["ImmersiveVR"] = "immersive-vr";
    XRSessionMode["ImmersiveAR"] = "immersive-ar";
})(XRSessionMode || (XRSessionMode = {}));
var XREnvironmentBlendMode;
(function (XREnvironmentBlendMode) {
    XREnvironmentBlendMode["Opaque"] = "opaque";
    XREnvironmentBlendMode["AlphaBlend"] = "alpha-blend";
    XREnvironmentBlendMode["Additive"] = "additive";
})(XREnvironmentBlendMode || (XREnvironmentBlendMode = {}));
var XRInteractionMode;
(function (XRInteractionMode) {
    XRInteractionMode["ScreenSpace"] = "screen-space";
    XRInteractionMode["WorldSpace"] = "world-space";
})(XRInteractionMode || (XRInteractionMode = {}));
const PRIVATE$6 = Symbol('@immersive-web-emulation-runtime/xr-session');
class XRSession extends EventTarget {
    constructor(device, mode, enabledFeatures) {
        super();
        this[PRIVATE$6] = {
            device,
            mode,
            renderState: new XRRenderState(),
            pendingRenderState: null,
            enabledFeatures: enabledFeatures,
            isSystemKeyboardSupported: false,
            ended: false,
            projectionMatrices: {
                [XREye.Left]: create$3(),
                [XREye.Right]: create$3(),
                [XREye.None]: create$3(),
            },
            getProjectionMatrix: (eye) => {
                return this[PRIVATE$6].projectionMatrices[eye];
            },
            referenceSpaceIsSupported: (referenceSpaceType) => {
                if (!this[PRIVATE$6].enabledFeatures.includes(referenceSpaceType)) {
                    return false;
                }
                switch (referenceSpaceType) {
                    case XRReferenceSpaceType.Viewer:
                        return true;
                    case XRReferenceSpaceType.Local:
                    case XRReferenceSpaceType.LocalFloor:
                    case XRReferenceSpaceType.BoundedFloor:
                    case XRReferenceSpaceType.Unbounded:
                        return this[PRIVATE$6].mode != XRSessionMode.Inline;
                }
            },
            frameHandle: 0,
            frameCallbacks: [],
            currentFrameCallbacks: null,
            onDeviceFrame: () => {
                if (this[PRIVATE$6].ended) {
                    return;
                }
                this[PRIVATE$6].deviceFrameHandle = globalThis.requestAnimationFrame(this[PRIVATE$6].onDeviceFrame);
                if (this[PRIVATE$6].pendingRenderState != null) {
                    this[PRIVATE$6].renderState = this[PRIVATE$6].pendingRenderState;
                    this[PRIVATE$6].pendingRenderState = null;
                    this[PRIVATE$6].device[PRIVATE$1].onBaseLayerSet(this[PRIVATE$6].renderState.baseLayer);
                }
                const baseLayer = this[PRIVATE$6].renderState.baseLayer;
                if (baseLayer === null) {
                    return;
                }
                const context = baseLayer.context;
                const canvas = context.canvas;
                /**
                 * This code snippet is designed to clear the buffers attached to an opaque framebuffer
                 * at the beginning of each XR animation frame, but it only applies to immersive XR sessions.
                 * The process is as follows:
                 *
                 * 1. Check if the session is immersive: It verifies if `session.immersive` is true.
                 *    This ensures that the buffer clearing operations are only performed for immersive
                 *    sessions, which have exclusive access to the XR device's display.
                 *
                 * 2. Save current clear values: The current clear values for the color, depth, and
                 *    stencil buffers are stored. These values need to be restored after clearing the
                 *    buffers to maintain the application's rendering state as expected.
                 *
                 * 3. Set clear values to defaults: The clear color is set to transparent black, the
                 *    clear depth to the maximum depth value (1.0), and the clear stencil to 0. This
                 *    ensures that the buffers are reset to a known state, free from any residual data.
                 *
                 * 4. Clear the buffers: The depth, color, and stencil buffers are cleared, removing
                 *    any content from previous frames and preparing them for new rendering operations.
                 *
                 * 5. Restore previous clear values: The original clear values are reinstated to return
                 *    the WebGL context to its state prior to this operation, allowing subsequent rendering
                 *    to proceed without interference.
                 *
                 * This clearing process is crucial for some XR devices to function correctly and to
                 * prevent rendering artifacts from past frames. It ensures that each new frame starts
                 * with a clean slate.
                 */
                if (this[PRIVATE$6].mode != XRSessionMode.Inline) {
                    const currentClearColor = context.getParameter(context.COLOR_CLEAR_VALUE);
                    const currentClearDepth = context.getParameter(context.DEPTH_CLEAR_VALUE);
                    const currentClearStencil = context.getParameter(context.STENCIL_CLEAR_VALUE);
                    context.clearColor(0.0, 0.0, 0.0, 0.0);
                    context.clearDepth(1);
                    context.clearStencil(0.0);
                    context.clear(context.DEPTH_BUFFER_BIT |
                        context.COLOR_BUFFER_BIT |
                        context.STENCIL_BUFFER_BIT);
                    context.clearColor(currentClearColor[0], currentClearColor[1], currentClearColor[2], currentClearColor[3]);
                    context.clearDepth(currentClearDepth);
                    context.clearStencil(currentClearStencil);
                }
                // Calculate projection matrices
                const { depthNear, depthFar } = this[PRIVATE$6].renderState;
                const { width, height } = canvas;
                if (this[PRIVATE$6].mode !== XRSessionMode.Inline) {
                    const aspect = (width * (this[PRIVATE$6].device.stereoEnabled ? 0.5 : 1.0)) / height;
                    perspective(this[PRIVATE$6].projectionMatrices[XREye.Left], this[PRIVATE$6].device.fovy, aspect, depthNear, depthFar);
                    copy$3(this[PRIVATE$6].projectionMatrices[XREye.Right], this[PRIVATE$6].projectionMatrices[XREye.Left]);
                }
                else {
                    const aspect = width / height;
                    perspective(this[PRIVATE$6].projectionMatrices[XREye.None], this[PRIVATE$6].renderState.inlineVerticalFieldOfView, aspect, depthNear, depthFar);
                }
                const frame = new XRFrame(this, this[PRIVATE$6].frameHandle, true, true, performance.now());
                this[PRIVATE$6].device[PRIVATE$1].onFrameStart(frame);
                this[PRIVATE$6].updateActiveInputSources();
                /*
                 * For each entry in callbacks, in order:
                 * - If the entry’s cancelled boolean is true, continue to the next entry.
                 * - Invoke the Web IDL callback function, passing now and frame as the arguments.
                 * - If an exception is thrown, report the exception.
                 */
                // - Let callbacks be a list of the entries in session’s list of animation frame
                //   callback, in the order in which they were added to the list.
                const callbacks = (this[PRIVATE$6].currentFrameCallbacks =
                    this[PRIVATE$6].frameCallbacks);
                // - Set session’s list of animation frame callbacks to the empty list.
                this[PRIVATE$6].frameCallbacks = [];
                const rightNow = performance.now();
                for (let i = 0; i < callbacks.length; i++) {
                    try {
                        if (!callbacks[i].cancelled) {
                            callbacks[i].callback(rightNow, frame);
                        }
                    }
                    catch (err) {
                        console.error(err);
                    }
                }
                this[PRIVATE$6].currentFrameCallbacks = null;
                // - Set frame’s active boolean to false.
                frame[PRIVATE$a].active = false;
            },
            nominalFrameRate: device.internalNominalFrameRate,
            referenceSpaces: [],
            inputSourceArray: [],
            activeInputSources: [],
            updateActiveInputSources: () => {
                const handTrackingOn = this[PRIVATE$6].enabledFeatures.includes(WebXRFeatures.HandTracking);
                const prevInputs = this[PRIVATE$6].activeInputSources;
                const currInputs = this[PRIVATE$6].device.inputSources.filter((inputSource) => !inputSource.hand || handTrackingOn);
                const added = currInputs.filter((item) => !prevInputs.includes(item));
                const removed = prevInputs.filter((item) => !currInputs.includes(item));
                this[PRIVATE$6].activeInputSources = currInputs;
                if (added.length > 0 || removed.length > 0) {
                    this.dispatchEvent(new XRInputSourcesChangeEvent('inputsourceschange', {
                        session: this,
                        added,
                        removed,
                    }));
                }
            },
            onend: null,
            oninputsourceschange: null,
            onselect: null,
            onselectstart: null,
            onselectend: null,
            onsqueeze: null,
            onsqueezestart: null,
            onsqueezeend: null,
            onvisibilitychange: null,
            onframeratechange: null,
        };
        // start the frameloop
        this[PRIVATE$6].onDeviceFrame();
    }
    get visibilityState() {
        return this[PRIVATE$6].device.visibilityState;
    }
    get frameRate() {
        return this[PRIVATE$6].nominalFrameRate;
    }
    get supportedFrameRates() {
        return new Float32Array(this[PRIVATE$6].device.supportedFrameRates);
    }
    get renderState() {
        return this[PRIVATE$6].renderState;
    }
    get inputSources() {
        // use the same array object
        this[PRIVATE$6].inputSourceArray.length = 0;
        if (!this[PRIVATE$6].ended && this[PRIVATE$6].mode !== XRSessionMode.Inline) {
            this[PRIVATE$6].inputSourceArray.push(...this[PRIVATE$6].activeInputSources);
        }
        return this[PRIVATE$6].inputSourceArray;
    }
    get enabledFeatures() {
        return this[PRIVATE$6].enabledFeatures;
    }
    get isSystemKeyboardSupported() {
        return this[PRIVATE$6].isSystemKeyboardSupported;
    }
    get environmentBlendMode() {
        var _a;
        return ((_a = this[PRIVATE$6].device[PRIVATE$1].environmentBlendModes[this[PRIVATE$6].mode]) !== null && _a !== void 0 ? _a : XREnvironmentBlendMode.Opaque);
    }
    get interactionMode() {
        return this[PRIVATE$6].device[PRIVATE$1].interactionMode;
    }
    updateRenderState(state = {}) {
        var _a, _b, _c, _d;
        if (this[PRIVATE$6].ended) {
            throw new DOMException('XRSession has already ended.', 'InvalidStateError');
        }
        if (state.baseLayer &&
            state.baseLayer[PRIVATE$7].session !== this) {
            throw new DOMException('Base layer was created by a different XRSession', 'InvalidStateError');
        }
        if (state.inlineVerticalFieldOfView != null &&
            this[PRIVATE$6].mode !== XRSessionMode.Inline) {
            throw new DOMException('InlineVerticalFieldOfView must not be set for an immersive session', 'InvalidStateError');
        }
        const compoundStateInit = {
            baseLayer: state.baseLayer ||
                ((_a = this[PRIVATE$6].pendingRenderState) === null || _a === void 0 ? void 0 : _a.baseLayer) ||
                undefined,
            depthFar: state.depthFar ||
                ((_b = this[PRIVATE$6].pendingRenderState) === null || _b === void 0 ? void 0 : _b.depthFar) ||
                undefined,
            depthNear: state.depthNear ||
                ((_c = this[PRIVATE$6].pendingRenderState) === null || _c === void 0 ? void 0 : _c.depthNear) ||
                undefined,
            inlineVerticalFieldOfView: state.inlineVerticalFieldOfView ||
                ((_d = this[PRIVATE$6].pendingRenderState) === null || _d === void 0 ? void 0 : _d.inlineVerticalFieldOfView) ||
                undefined,
        };
        this[PRIVATE$6].pendingRenderState = new XRRenderState(compoundStateInit, this[PRIVATE$6].renderState);
    }
    // the nominal frame rate updates are emulated, no actual update to the
    // display frame rate of the device will be executed
    async updateTargetFrameRate(rate) {
        return new Promise((resolve, reject) => {
            if (this[PRIVATE$6].ended) {
                reject(new DOMException('XRSession has already ended.', 'InvalidStateError'));
            }
            else if (!this[PRIVATE$6].device.supportedFrameRates.includes(rate)) {
                reject(new DOMException('Requested frame rate not supported.', 'InvalidStateError'));
            }
            else {
                if (this[PRIVATE$6].nominalFrameRate === rate) {
                    console.log(`Requested frame rate is the same as the current nominal frame rate, no update made`);
                }
                else {
                    this[PRIVATE$6].nominalFrameRate = rate;
                    this.dispatchEvent(new XRSessionEvent('frameratechange', { session: this }));
                    console.log(`Nominal frame rate updated to ${rate}`);
                }
                resolve();
            }
        });
    }
    async requestReferenceSpace(type) {
        return new Promise((resolve, reject) => {
            if (this[PRIVATE$6].ended ||
                !this[PRIVATE$6].referenceSpaceIsSupported(type)) {
                reject(new DOMException('The requested reference space type is not supported.', 'NotSupportedError'));
                return;
            }
            let referenceSpace;
            switch (type) {
                case XRReferenceSpaceType.Viewer:
                    referenceSpace = this[PRIVATE$6].device.viewerSpace;
                    break;
                case XRReferenceSpaceType.Local:
                    // creating an XRReferenceSpace with the current headset transform in global space
                    referenceSpace = new XRReferenceSpace(type, this[PRIVATE$6].device[PRIVATE$1].globalSpace, this[PRIVATE$6].device.viewerSpace[PRIVATE$l].offsetMatrix);
                    break;
                case XRReferenceSpaceType.LocalFloor:
                case XRReferenceSpaceType.BoundedFloor:
                case XRReferenceSpaceType.Unbounded:
                    // TO-DO: add boundary geometry for bounded-floor
                    referenceSpace = new XRReferenceSpace(type, this[PRIVATE$6].device[PRIVATE$1].globalSpace);
                    break;
            }
            this[PRIVATE$6].referenceSpaces.push(referenceSpace);
            resolve(referenceSpace);
        });
    }
    requestAnimationFrame(callback) {
        if (this[PRIVATE$6].ended) {
            return 0;
        }
        const frameHandle = ++this[PRIVATE$6].frameHandle;
        this[PRIVATE$6].frameCallbacks.push({
            handle: frameHandle,
            callback,
            cancelled: false,
        });
        return frameHandle;
    }
    cancelAnimationFrame(handle) {
        // Remove the callback with that handle from the queue
        let callbacks = this[PRIVATE$6].frameCallbacks;
        let index = callbacks.findIndex((d) => d && d.handle === handle);
        if (index > -1) {
            callbacks[index].cancelled = true;
            callbacks.splice(index, 1);
        }
        // If cancelAnimationFrame is called from within a frame callback, also check
        // the remaining callbacks for the current frame:
        callbacks = this[PRIVATE$6].currentFrameCallbacks;
        if (callbacks) {
            index = callbacks.findIndex((d) => d && d.handle === handle);
            if (index > -1) {
                callbacks[index].cancelled = true;
                // Rely on cancelled flag only; don't mutate this array while it's being iterated
            }
        }
    }
    async end() {
        return new Promise((resolve, reject) => {
            if (this[PRIVATE$6].ended || this[PRIVATE$6].deviceFrameHandle === null) {
                reject(new DOMException('XRSession has already ended.', 'InvalidStateError'));
            }
            else {
                globalThis.cancelAnimationFrame(this[PRIVATE$6].deviceFrameHandle);
                this[PRIVATE$6].device[PRIVATE$1].onSessionEnd();
                this.dispatchEvent(new XRSessionEvent('end', { session: this }));
                resolve();
            }
        });
    }
    // events
    get onend() {
        var _a;
        return (_a = this[PRIVATE$6].onend) !== null && _a !== void 0 ? _a : (() => { });
    }
    set onend(callback) {
        if (this[PRIVATE$6].onend) {
            this.removeEventListener('end', this[PRIVATE$6].onend);
        }
        this[PRIVATE$6].onend = callback;
        if (callback) {
            this.addEventListener('end', callback);
        }
    }
    get oninputsourceschange() {
        var _a;
        return (_a = this[PRIVATE$6].oninputsourceschange) !== null && _a !== void 0 ? _a : (() => { });
    }
    set oninputsourceschange(callback) {
        if (this[PRIVATE$6].oninputsourceschange) {
            this.removeEventListener('inputsourceschange', this[PRIVATE$6].oninputsourceschange);
        }
        this[PRIVATE$6].oninputsourceschange = callback;
        if (callback) {
            this.addEventListener('inputsourceschange', callback);
        }
    }
    get onselect() {
        var _a;
        return (_a = this[PRIVATE$6].onselect) !== null && _a !== void 0 ? _a : (() => { });
    }
    set onselect(callback) {
        if (this[PRIVATE$6].onselect) {
            this.removeEventListener('select', this[PRIVATE$6].onselect);
        }
        this[PRIVATE$6].onselect = callback;
        if (callback) {
            this.addEventListener('select', callback);
        }
    }
    get onselectstart() {
        var _a;
        return (_a = this[PRIVATE$6].onselectstart) !== null && _a !== void 0 ? _a : (() => { });
    }
    set onselectstart(callback) {
        if (this[PRIVATE$6].onselectstart) {
            this.removeEventListener('selectstart', this[PRIVATE$6].onselectstart);
        }
        this[PRIVATE$6].onselectstart = callback;
        if (callback) {
            this.addEventListener('selectstart', callback);
        }
    }
    get onselectend() {
        var _a;
        return (_a = this[PRIVATE$6].onselectend) !== null && _a !== void 0 ? _a : (() => { });
    }
    set onselectend(callback) {
        if (this[PRIVATE$6].onselectend) {
            this.removeEventListener('selectend', this[PRIVATE$6].onselectend);
        }
        this[PRIVATE$6].onselectend = callback;
        if (callback) {
            this.addEventListener('selectend', callback);
        }
    }
    get onsqueeze() {
        var _a;
        return (_a = this[PRIVATE$6].onsqueeze) !== null && _a !== void 0 ? _a : (() => { });
    }
    set onsqueeze(callback) {
        if (this[PRIVATE$6].onsqueeze) {
            this.removeEventListener('squeeze', this[PRIVATE$6].onsqueeze);
        }
        this[PRIVATE$6].onsqueeze = callback;
        if (callback) {
            this.addEventListener('squeeze', callback);
        }
    }
    get onsqueezestart() {
        var _a;
        return (_a = this[PRIVATE$6].onsqueezestart) !== null && _a !== void 0 ? _a : (() => { });
    }
    set onsqueezestart(callback) {
        if (this[PRIVATE$6].onsqueezestart) {
            this.removeEventListener('squeezestart', this[PRIVATE$6].onsqueezestart);
        }
        this[PRIVATE$6].onsqueezestart = callback;
        if (callback) {
            this.addEventListener('squeezestart', callback);
        }
    }
    get onsqueezeend() {
        var _a;
        return (_a = this[PRIVATE$6].onsqueezeend) !== null && _a !== void 0 ? _a : (() => { });
    }
    set onsqueezeend(callback) {
        if (this[PRIVATE$6].onsqueezeend) {
            this.removeEventListener('squeezeend', this[PRIVATE$6].onsqueezeend);
        }
        this[PRIVATE$6].onsqueezeend = callback;
        if (callback) {
            this.addEventListener('squeezeend', callback);
        }
    }
    get onvisibilitychange() {
        var _a;
        return (_a = this[PRIVATE$6].onvisibilitychange) !== null && _a !== void 0 ? _a : (() => { });
    }
    set onvisibilitychange(callback) {
        if (this[PRIVATE$6].onvisibilitychange) {
            this.removeEventListener('visibilitychange', this[PRIVATE$6].onvisibilitychange);
        }
        this[PRIVATE$6].onvisibilitychange = callback;
        if (callback) {
            this.addEventListener('visibilitychange', callback);
        }
    }
    get onframeratechange() {
        var _a;
        return (_a = this[PRIVATE$6].onframeratechange) !== null && _a !== void 0 ? _a : (() => { });
    }
    set onframeratechange(callback) {
        if (this[PRIVATE$6].onframeratechange) {
            this.removeEventListener('frameratechange', this[PRIVATE$6].onframeratechange);
        }
        this[PRIVATE$6].onframeratechange = callback;
        if (callback) {
            this.addEventListener('frameratechange', callback);
        }
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var XRHandJoint;
(function (XRHandJoint) {
    XRHandJoint["Wrist"] = "wrist";
    XRHandJoint["ThumbMetacarpal"] = "thumb-metacarpal";
    XRHandJoint["ThumbPhalanxProximal"] = "thumb-phalanx-proximal";
    XRHandJoint["ThumbPhalanxDistal"] = "thumb-phalanx-distal";
    XRHandJoint["ThumbTip"] = "thumb-tip";
    XRHandJoint["IndexFingerMetacarpal"] = "index-finger-metacarpal";
    XRHandJoint["IndexFingerPhalanxProximal"] = "index-finger-phalanx-proximal";
    XRHandJoint["IndexFingerPhalanxIntermediate"] = "index-finger-phalanx-intermediate";
    XRHandJoint["IndexFingerPhalanxDistal"] = "index-finger-phalanx-distal";
    XRHandJoint["IndexFingerTip"] = "index-finger-tip";
    XRHandJoint["MiddleFingerMetacarpal"] = "middle-finger-metacarpal";
    XRHandJoint["MiddleFingerPhalanxProximal"] = "middle-finger-phalanx-proximal";
    XRHandJoint["MiddleFingerPhalanxIntermediate"] = "middle-finger-phalanx-intermediate";
    XRHandJoint["MiddleFingerPhalanxDistal"] = "middle-finger-phalanx-distal";
    XRHandJoint["MiddleFingerTip"] = "middle-finger-tip";
    XRHandJoint["RingFingerMetacarpal"] = "ring-finger-metacarpal";
    XRHandJoint["RingFingerPhalanxProximal"] = "ring-finger-phalanx-proximal";
    XRHandJoint["RingFingerPhalanxIntermediate"] = "ring-finger-phalanx-intermediate";
    XRHandJoint["RingFingerPhalanxDistal"] = "ring-finger-phalanx-distal";
    XRHandJoint["RingFingerTip"] = "ring-finger-tip";
    XRHandJoint["PinkyFingerMetacarpal"] = "pinky-finger-metacarpal";
    XRHandJoint["PinkyFingerPhalanxProximal"] = "pinky-finger-phalanx-proximal";
    XRHandJoint["PinkyFingerPhalanxIntermediate"] = "pinky-finger-phalanx-intermediate";
    XRHandJoint["PinkyFingerPhalanxDistal"] = "pinky-finger-phalanx-distal";
    XRHandJoint["PinkyFingerTip"] = "pinky-finger-tip";
})(XRHandJoint || (XRHandJoint = {}));
class XRHand extends Map {
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const pinchHandPose = {
    jointTransforms: {
        wrist: {
            offsetMatrix: [
                0.9060805439949036, -0.1844543218612671, 0.3807799518108368, 0,
                -0.08027800172567368, 0.8086723685264587, 0.5827555656433105, 0,
                -0.4154181182384491, -0.5585917234420776, 0.7179155349731445, 0,
                -0.06867414712905884, -0.009423808194696903, 0.10627774149179459, 1,
            ],
            radius: 0.021460847929120064,
        },
        'thumb-metacarpal': {
            offsetMatrix: [
                -0.5012241005897522, -0.8650535345077515, -0.0213695727288723, 0,
                0.7415963411331177, -0.4421543478965759, 0.5045139193534851, 0,
                -0.44587990641593933, 0.23702676594257355, 0.8631392121315002, 0,
                -0.032122574746608734, -0.01196830440312624, 0.07194234430789948, 1,
            ],
            radius: 0.019382517784833908,
        },
        'thumb-phalanx-proximal': {
            offsetMatrix: [
                -0.3175753057003021, -0.9460570216178894, -0.06419729441404343, 0,
                0.8958902955055237, -0.32153913378715515, 0.30658137798309326, 0,
                -0.3106854259967804, 0.03984907269477844, 0.9496771097183228, 0,
                -0.017625702545046806, -0.01967475935816765, 0.04387917369604111, 1,
            ],
            radius: 0.01228295173496008,
        },
        'thumb-phalanx-distal': {
            offsetMatrix: [
                -0.4944636821746826, -0.8691971898078918, 0.001086252392269671, 0,
                0.8307800889015198, -0.4722411036491394, 0.2946045398712158, 0,
                -0.25555649399757385, 0.14657381176948547, 0.9556186199188232, 0,
                -0.007126678712666035, -0.021021386608481407, 0.011786630377173424, 1,
            ],
            radius: 0.009768804535269737,
        },
        'thumb-tip': {
            offsetMatrix: [
                -0.4944636821746826, -0.8691971898078918, 0.001086252392269671, 0,
                0.8307800889015198, -0.4722411036491394, 0.2946045398712158, 0,
                -0.25555649399757385, 0.14657381176948547, 0.9556186199188232, 0,
                0.0003423091256991029, -0.024528030306100845, -0.011410919018089771, 1,
            ],
            radius: 0.008768804371356964,
        },
        'index-finger-metacarpal': {
            offsetMatrix: [
                0.9060805439949036, -0.1844543218612671, 0.3807799518108368, 0,
                -0.08027800172567368, 0.8086723685264587, 0.5827555656433105, 0,
                -0.4154181182384491, -0.5585917234420776, 0.7179155349731445, 0,
                -0.038037415593862534, -0.0020236473064869642, 0.07626739144325256, 1,
            ],
            radius: 0.021228281781077385,
        },
        'index-finger-phalanx-proximal': {
            offsetMatrix: [
                0.7986818552017212, -0.35985732078552246, 0.48229536414146423, 0,
                0.538311243057251, 0.7854709625244141, -0.30537736415863037, 0,
                -0.2689369022846222, 0.5035246014595032, 0.8210577368736267, 0,
                -0.006869405973702669, 0.033938243985176086, 0.04206443578004837, 1,
            ],
            radius: 0.010295259766280651,
        },
        'index-finger-phalanx-intermediate': {
            offsetMatrix: [
                0.8285930156707764, -0.32672837376594543, 0.4546217918395996, 0,
                0.5577570199966431, 0.4116027057170868, -0.7207564115524292, 0,
                0.04836784675717354, 0.8507823944091797, 0.5232869386672974, 0,
                0.0033306588884443045, 0.014840902760624886, 0.010923954658210278, 1,
            ],
            radius: 0.00853810179978609,
        },
        'index-finger-phalanx-distal': {
            offsetMatrix: [
                0.8412464261054993, -0.35794928669929504, 0.4051857888698578, 0,
                0.5139996409416199, 0.29711154103279114, -0.8046918511390686, 0,
                0.16765329241752625, 0.8852096796035767, 0.4339304566383362, 0,
                0.0021551470272243023, -0.0058362227864563465, -0.0017938464879989624,
                1,
            ],
            radius: 0.007636196445673704,
        },
        'index-finger-tip': {
            offsetMatrix: [
                0.8412464261054993, -0.35794928669929504, 0.4051857888698578, 0,
                0.5139996409416199, 0.29711154103279114, -0.8046918511390686, 0,
                0.16765329241752625, 0.8852096796035767, 0.4339304566383362, 0,
                -0.00131594471167773, -0.025222131982445717, -0.012442642822861671, 1,
            ],
            radius: 0.006636196281760931,
        },
        'middle-finger-metacarpal': {
            offsetMatrix: [
                0.9060805439949036, -0.1844543218612671, 0.3807799518108368, 0,
                -0.08027800172567368, 0.8086723685264587, 0.5827555656433105, 0,
                -0.4154181182384491, -0.5585917234420776, 0.7179155349731445, 0,
                -0.05395089089870453, 0.003063359996303916, 0.07402937114238739, 1,
            ],
            radius: 0.021231964230537415,
        },
        'middle-finger-phalanx-proximal': {
            offsetMatrix: [
                0.9187911748886108, -0.1530158370733261, 0.36387869715690613, 0,
                0.038666240870952606, 0.9522662162780762, 0.302808940410614, 0,
                -0.3928440511226654, -0.26414817571640015, 0.8808513283729553, 0,
                -0.02717282809317112, 0.04162866622209549, 0.03678669035434723, 1,
            ],
            radius: 0.01117393933236599,
        },
        'middle-finger-phalanx-intermediate': {
            offsetMatrix: [
                0.9228746294975281, -0.12856416404247284, 0.36300456523895264, 0,
                0.14524033665657043, 0.9892153143882751, -0.01890045404434204, 0,
                -0.3566599190235138, 0.07016586512327194, 0.9315956234931946, 0,
                -0.01030921470373869, 0.05296773463487625, -0.0010256498353555799, 1,
            ],
            radius: 0.008030958473682404,
        },
        'middle-finger-phalanx-distal': {
            offsetMatrix: [
                0.9325166344642639, -0.040404170751571655, 0.35885775089263916, 0,
                0.06836572289466858, 0.995502769947052, -0.0655682161450386, 0,
                -0.3545948565006256, 0.08567725121974945, 0.9310863614082336, 0,
                -0.0004833847051486373, 0.05103470757603645, -0.026690717786550522, 1,
            ],
            radius: 0.007629410829395056,
        },
        'middle-finger-tip': {
            offsetMatrix: [
                0.9325166344642639, -0.040404170751571655, 0.35885775089263916, 0,
                0.06836572289466858, 0.995502769947052, -0.0655682161450386, 0,
                -0.3545948565006256, 0.08567725121974945, 0.9310863614082336, 0,
                0.008158999495208263, 0.05004044249653816, -0.050120558589696884, 1,
            ],
            radius: 0.006629410665482283,
        },
        'ring-finger-metacarpal': {
            offsetMatrix: [
                0.9060805439949036, -0.1844543218612671, 0.3807799518108368, 0,
                -0.08027800172567368, 0.8086723685264587, 0.5827555656433105, 0,
                -0.4154181182384491, -0.5585917234420776, 0.7179155349731445, 0,
                -0.06732909381389618, 0.007902119308710098, 0.07209732383489609, 1,
            ],
            radius: 0.019088275730609894,
        },
        'ring-finger-phalanx-proximal': {
            offsetMatrix: [
                0.9391821026802063, -0.027994679287075996, 0.34227466583251953, 0,
                -0.18282271921634674, 0.8029410243034363, 0.5673282742500305, 0,
                -0.2907087206840515, -0.5954000353813171, 0.7489906549453735, 0,
                -0.047129884362220764, 0.03806127607822418, 0.032147664576768875, 1,
            ],
            radius: 0.00992213748395443,
        },
        'ring-finger-phalanx-intermediate': {
            offsetMatrix: [
                0.9249380826950073, 0.03699534013867378, 0.3783116042613983, 0,
                -0.12898847460746765, 0.9667453765869141, 0.2208271026611328, 0,
                -0.3575615882873535, -0.25304901599884033, 0.8989526629447937, 0,
                -0.03579339757561684, 0.06127955764532089, 0.002939916681498289, 1,
            ],
            radius: 0.007611672393977642,
        },
        'ring-finger-phalanx-distal': {
            offsetMatrix: [
                0.9001164436340332, 0.03983335196971893, 0.4338230490684509, 0,
                -0.09662467986345291, 0.9892624020576477, 0.10964841395616531, 0,
                -0.4247973561286926, -0.14061418175697327, 0.8943013548851013, 0,
                -0.026291755959391594, 0.06800390034914017, -0.02094830758869648, 1,
            ],
            radius: 0.007231088820844889,
        },
        'ring-finger-tip': {
            offsetMatrix: [
                0.9001164436340332, 0.03983335196971893, 0.4338230490684509, 0,
                -0.09662467986345291, 0.9892624020576477, 0.10964841395616531, 0,
                -0.4247973561286926, -0.14061418175697327, 0.8943013548851013, 0,
                -0.016345610842108727, 0.07300511747598648, -0.04263874143362045, 1,
            ],
            radius: 0.0062310886569321156,
        },
        'pinky-finger-metacarpal': {
            offsetMatrix: [
                0.8769711852073669, 0.31462907791137695, 0.36322021484375, 0,
                -0.4506046175956726, 0.801031768321991, 0.39408499002456665, 0,
                -0.16696058213710785, -0.5092697143554688, 0.8442559838294983, 0,
                -0.07460174709558487, 0.0062340241856873035, 0.06756893545389175, 1,
            ],
            radius: 0.01808827556669712,
        },
        'pinky-finger-phalanx-proximal': {
            offsetMatrix: [
                0.9498357176780701, 0.1553308218717575, 0.2714462876319885, 0,
                -0.3019258379936218, 0.6817675232887268, 0.6663586497306824, 0,
                -0.08155745267868042, -0.7148879170417786, 0.694466233253479, 0,
                -0.06697750836610794, 0.029482364654541016, 0.02902858518064022, 1,
            ],
            radius: 0.008483353070914745,
        },
        'pinky-finger-phalanx-intermediate': {
            offsetMatrix: [
                0.9214097261428833, 0.27928245067596436, 0.2701927423477173, 0,
                -0.3670244514942169, 0.8538867831230164, 0.36901235580444336, 0,
                -0.12765564024448395, -0.43917882442474365, 0.8892839550971985, 0,
                -0.06447203457355499, 0.05144399777054787, 0.0076942890882492065, 1,
            ],
            radius: 0.0067641944624483585,
        },
        'pinky-finger-phalanx-distal': {
            offsetMatrix: [
                0.9038633704185486, 0.23618005216121674, 0.3567195236682892, 0,
                -0.3532794713973999, 0.8823202252388, 0.3109731376171112, 0,
                -0.24129553139209747, -0.4070987403392792, 0.8809353709220886, 0,
                -0.06187915802001953, 0.060364335775375366, -0.010368337854743004, 1,
            ],
            radius: 0.0064259846694767475,
        },
        'pinky-finger-tip': {
            offsetMatrix: [
                0.9038633704185486, 0.23618005216121674, 0.3567195236682892, 0,
                -0.3532794713973999, 0.8823202252388, 0.3109731376171112, 0,
                -0.24129553139209747, -0.4070987403392792, 0.8809353709220886, 0,
                -0.056796226650476456, 0.07042007893323898, -0.02921444922685623, 1,
            ],
            radius: 0.005425984505563974,
        },
    },
    gripOffsetMatrix: [
        0.08027800917625427, -0.8086723685264587, -0.5827556252479553, 0,
        -0.4154181480407715, -0.5585916638374329, 0.7179154753684998, 0,
        -0.9060805439949036, 0.1844543218612671, -0.3807799518108368, 0,
        -0.038054611533880234, -0.002910431008785963, 0.03720742464065552, 1,
    ],
};

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const pointHandPose = {
    jointTransforms: {
        wrist: {
            offsetMatrix: [
                0.9340395331382751, -0.13936476409435272, 0.32885703444480896, 0,
                -0.005510995630174875, 0.914999783039093, 0.40341612696647644, 0,
                -0.3571262061595917, -0.37861889600753784, 0.8538784384727478, 0,
                -0.05789132043719292, 0.01670890860259533, 0.11183350533246994, 1,
            ],
            radius: 0.021460847929120064,
        },
        'thumb-metacarpal': {
            offsetMatrix: [
                0.02145560085773468, -0.9978390336036682, 0.0621047280728817, 0,
                0.41311800479888916, 0.06541631370782852, 0.9083252549171448, 0,
                -0.9104245901107788, 0.006167683284729719, 0.4136286973953247, 0,
                -0.016488194465637207, 0.012708572670817375, 0.08862338215112686, 1,
            ],
            radius: 0.019382517784833908,
        },
        'thumb-phalanx-proximal': {
            offsetMatrix: [
                0.21270370483398438, -0.966137707233429, 0.14606566727161407, 0,
                0.49890995025634766, 0.2359165996313095, 0.8339261412620544, 0,
                -0.8401462435722351, -0.10450579971075058, 0.5321959853172302, 0,
                0.013112368993461132, 0.012508046813309193, 0.07517509907484055, 1,
            ],
            radius: 0.01228295173496008,
        },
        'thumb-phalanx-distal': {
            offsetMatrix: [
                0.01653280481696129, -0.9986647963523865, 0.048943229019641876, 0,
                0.26313456892967224, 0.051570065319538116, 0.9633802771568298, 0,
                -0.9646173715591431, -0.0030490627977997065, 0.26363563537597656, 0,
                0.04150351136922836, 0.016039609909057617, 0.05719054117798805, 1,
            ],
            radius: 0.009768804535269737,
        },
        'thumb-tip': {
            offsetMatrix: [
                0.01653280481696129, -0.9986647963523865, 0.048943229019641876, 0,
                0.26313456892967224, 0.051570065319538116, 0.9633802771568298, 0,
                -0.9646173715591431, -0.0030490627977997065, 0.26363563537597656, 0,
                0.06548332422971725, 0.01683700829744339, 0.0516640841960907, 1,
            ],
            radius: 0.008768804371356964,
        },
        'index-finger-metacarpal': {
            offsetMatrix: [
                0.9340395331382751, -0.13936476409435272, 0.32885703444480896, 0,
                -0.005510995630174875, 0.914999783039093, 0.40341612696647644, 0,
                -0.3571262061595917, -0.37861889600753784, 0.8538784384727478, 0,
                -0.02592567168176174, 0.019982583820819855, 0.08479326963424683, 1,
            ],
            radius: 0.021228281781077385,
        },
        'index-finger-phalanx-proximal': {
            offsetMatrix: [
                0.9063700437545776, -0.21756279468536377, 0.3621589243412018, 0,
                0.0970839336514473, 0.9415287375450134, 0.3226419687271118, 0,
                -0.41117796301841736, -0.2572731077671051, 0.8744958639144897, 0,
                -0.0015709538711234927, 0.043078210204839706, 0.034657616168260574, 1,
            ],
            radius: 0.010295259766280651,
        },
        'index-finger-phalanx-intermediate': {
            offsetMatrix: [
                0.9159826040267944, -0.1651475727558136, 0.36565208435058594, 0,
                0.09755707532167435, 0.9756820797920227, 0.1962820291519165, 0,
                -0.3891757130622864, -0.14411886036396027, 0.9098196625709534, 0,
                0.014023927971720695, 0.052835866808891296, 0.0014903299743309617, 1,
            ],
            radius: 0.00853810179978609,
        },
        'index-finger-phalanx-distal': {
            offsetMatrix: [
                0.9378057718276978, -0.12329639494419098, 0.3245268166065216, 0,
                0.032558172941207886, 0.9619227051734924, 0.2713746726512909, 0,
                -0.3456292748451233, -0.2439306229352951, 0.9061115384101868, 0,
                0.023482320830225945, 0.05633850023150444, -0.020621655508875847, 1,
            ],
            radius: 0.007636196445673704,
        },
        'index-finger-tip': {
            offsetMatrix: [
                0.9378057718276978, -0.12329639494419098, 0.3245268166065216, 0,
                0.032558172941207886, 0.9619227051734924, 0.2713746726512909, 0,
                -0.3456292748451233, -0.2439306229352951, 0.9061115384101868, 0,
                0.03096788562834263, 0.06281610578298569, -0.040703095495700836, 1,
            ],
            radius: 0.006636196281760931,
        },
        'middle-finger-metacarpal': {
            offsetMatrix: [
                0.9340395331382751, -0.13936476409435272, 0.32885703444480896, 0,
                -0.005510995630174875, 0.914999783039093, 0.40341612696647644, 0,
                -0.3571262061595917, -0.37861889600753784, 0.8538784384727478, 0,
                -0.04184452444314957, 0.022474845871329308, 0.08177298307418823, 1,
            ],
            radius: 0.021231964230537415,
        },
        'middle-finger-phalanx-proximal': {
            offsetMatrix: [
                0.9720265865325928, -0.08313076198101044, 0.21966552734375, 0,
                0.20477405190467834, 0.7580050826072693, -0.6192700862884521, 0,
                -0.11502730846405029, 0.6469289064407349, 0.7538246512413025, 0,
                -0.022107340395450592, 0.05035499855875969, 0.02970452979207039, 1,
            ],
            radius: 0.01117393933236599,
        },
        'middle-finger-phalanx-intermediate': {
            offsetMatrix: [
                0.9779140949249268, -0.07129573822021484, 0.19646917283535004, 0,
                0.1287083923816681, -0.5352076292037964, -0.8348574042320251, 0,
                0.1646735966205597, 0.8417060971260071, -0.5142109394073486, 0,
                -0.017169542610645294, 0.022584279999136925, -0.00265491777099669, 1,
            ],
            radius: 0.008030958473682404,
        },
        'middle-finger-phalanx-distal': {
            offsetMatrix: [
                0.9774913787841797, -0.19657190144062042, 0.07661263644695282, 0,
                -0.1924918293952942, -0.9796126484870911, -0.05749811604619026, 0,
                0.08635343611240387, 0.041456472128629684, -0.995401918888092, 0,
                -0.02170622907578945, -0.0006043742760084569, 0.011511396616697311, 1,
            ],
            radius: 0.007629410829395056,
        },
        'middle-finger-tip': {
            offsetMatrix: [
                0.9774913787841797, -0.19657190144062042, 0.07661263644695282, 0,
                -0.1924918293952942, -0.9796126484870911, -0.05749811604619026, 0,
                0.08635343611240387, 0.041456472128629684, -0.995401918888092, 0,
                -0.02438267692923546, -0.0026927536819130182, 0.03627248480916023, 1,
            ],
            radius: 0.006629410665482283,
        },
        'ring-finger-metacarpal': {
            offsetMatrix: [
                0.9340395331382751, -0.13936476409435272, 0.32885703444480896, 0,
                -0.005510995630174875, 0.914999783039093, 0.40341612696647644, 0,
                -0.3571262061595917, -0.37861889600753784, 0.8538784384727478, 0,
                -0.05944233387708664, 0.0264605600386858, 0.07478221505880356, 1,
            ],
            radius: 0.019088275730609894,
        },
        'ring-finger-phalanx-proximal': {
            offsetMatrix: [
                0.9842101335525513, 0.024470895528793335, 0.1753024309873581, 0,
                0.12200043350458145, 0.6237703561782837, -0.7720272541046143, 0,
                -0.12824076414108276, 0.7812241315841675, 0.610936164855957, 0,
                -0.04249368980526924, 0.0467497780919075, 0.027722163125872612, 1,
            ],
            radius: 0.00992213748395443,
        },
        'ring-finger-phalanx-intermediate': {
            offsetMatrix: [
                0.9941774606704712, 0.05949164181947708, 0.08983955532312393, 0,
                0.10504482686519623, -0.7208291888237, -0.6851072907447815, 0,
                0.024001073092222214, 0.6905553936958313, -0.7228817939758301, 0,
                -0.0374927744269371, 0.016285063698887825, 0.0038980208337306976, 1,
            ],
            radius: 0.007611672393977642,
        },
        'ring-finger-phalanx-distal': {
            offsetMatrix: [
                0.9995742440223694, 0.01638498157262802, 0.02412819117307663, 0,
                0.007813597097992897, -0.9474818110466003, 0.31971633434295654, 0,
                0.028100071474909782, -0.31939181685447693, -0.9472070932388306, 0,
                -0.038130562752485275, -0.0020653479732573032, 0.02310742810368538, 1,
            ],
            radius: 0.007231088820844889,
        },
        'ring-finger-tip': {
            offsetMatrix: [
                0.9995742440223694, 0.01638498157262802, 0.02412819117307663, 0,
                0.007813597097992897, -0.9474818110466003, 0.31971633434295654, 0,
                0.028100071474909782, -0.31939181685447693, -0.9472070932388306, 0,
                -0.0390593595802784, 0.004176302347332239, 0.0466572530567646, 1,
            ],
            radius: 0.0062310886569321156,
        },
        'pinky-finger-metacarpal': {
            offsetMatrix: [
                0.9147363901138306, 0.3458845317363739, 0.20885537564754486, 0,
                -0.3923271894454956, 0.8839452862739563, 0.2544005811214447, 0,
                -0.09662359952926636, -0.3146490156650543, 0.9442773461341858, 0,
                -0.06715242564678192, 0.024195827543735504, 0.07137546688318253, 1,
            ],
            radius: 0.01808827556669712,
        },
        'pinky-finger-phalanx-proximal': {
            offsetMatrix: [
                0.9613109827041626, 0.22439135611057281, 0.15977802872657776, 0,
                0.01002211682498455, 0.5511574745178223, -0.8343409299850464, 0,
                -0.27528178691864014, 0.8036624789237976, 0.5275853276252747, 0,
                -0.06273911893367767, 0.038559623062610626, 0.028268879279494286, 1,
            ],
            radius: 0.008483353070914745,
        },
        'pinky-finger-phalanx-intermediate': {
            offsetMatrix: [
                0.9820972084999084, 0.18811029195785522, -0.00995189044624567, 0,
                0.14063723385334015, -0.7673450708389282, -0.6256227493286133, 0,
                -0.12532226741313934, 0.6130226850509644, -0.7800630927085876, 0,
                -0.05428232625126839, 0.013870777562260628, 0.012061242014169693, 1,
            ],
            radius: 0.0067641944624483585,
        },
        'pinky-finger-phalanx-distal': {
            offsetMatrix: [
                0.9744614362716675, 0.20454788208007812, -0.09265263378620148, 0,
                0.22429193556308746, -0.9065253138542175, 0.35764020681381226, 0,
                -0.010836843401193619, -0.3692878782749176, -0.9292529225349426, 0,
                -0.05173685774207115, 0.0014194445684552193, 0.02790539152920246, 1,
            ],
            radius: 0.0064259846694767475,
        },
        'pinky-finger-tip': {
            offsetMatrix: [
                0.9744614362716675, 0.20454788208007812, -0.09265263378620148, 0,
                0.22429193556308746, -0.9065253138542175, 0.35764020681381226, 0,
                -0.010836843401193619, -0.3692878782749176, -0.9292529225349426, 0,
                -0.05098633095622063, 0.008463085629045963, 0.048688892275094986, 1,
            ],
            radius: 0.005425984505563974,
        },
    },
    gripOffsetMatrix: [
        0.005510995630174875, -0.9149997234344482, -0.40341615676879883, 0,
        -0.3571262061595917, -0.37861889600753784, 0.8538784384727478, 0,
        -0.9340395331382751, 0.13936474919319153, -0.32885703444480896, 0,
        -0.031803809106349945, 0.007837686687707901, 0.04313928261399269, 1,
    ],
};

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const relaxedHandPose = {
    jointTransforms: {
        wrist: {
            offsetMatrix: [
                0.9616971015930176, -0.13805118203163147, 0.2368120402097702, 0,
                0.0005348679260350764, 0.8648636937141418, 0.5020061135292053, 0,
                -0.2741127610206604, -0.48265108466148376, 0.8318111300468445, 0,
                -0.04913589730858803, 0.0021463718730956316, 0.11701996624469757, 1,
            ],
            radius: 0.021460847929120064,
        },
        'thumb-metacarpal': {
            offsetMatrix: [
                -0.07536252588033676, -0.9959676265716553, -0.04867160692811012, 0,
                0.5877083539962769, -0.08379616588354111, 0.8047218918800354, 0,
                -0.8055551648139954, 0.032041035592556, 0.5916536450386047, 0,
                -0.010643752291798592, 0.0006936835707165301, 0.08736639469861984, 1,
            ],
            radius: 0.019382517784833908,
        },
        'thumb-phalanx-proximal': {
            offsetMatrix: [
                0.1374533325433731, -0.9904957413673401, 0.004982374142855406, 0,
                0.5534393787384033, 0.08097179979085922, 0.8289443850517273, 0,
                -0.8214688897132874, -0.11118389666080475, 0.559309184551239, 0,
                0.015547193586826324, -0.0003480653394944966, 0.0681300163269043, 1,
            ],
            radius: 0.01228295173496008,
        },
        'thumb-phalanx-distal': {
            offsetMatrix: [
                -0.04659227654337883, -0.9974699020385742, -0.05369402840733528, 0,
                0.6812446117401123, -0.07104194164276123, 0.728600800037384, 0,
                -0.7305715084075928, -0.002631746232509613, 0.6828309893608093, 0,
                0.04330715537071228, 0.003409178927540779, 0.0492292083799839, 1,
            ],
            radius: 0.009768804535269737,
        },
        'thumb-tip': {
            offsetMatrix: [
                -0.04659227654337883, -0.9974699020385742, -0.05369402840733528, 0,
                0.6812446117401123, -0.07104194164276123, 0.728600800037384, 0,
                -0.7305715084075928, -0.002631746232509613, 0.6828309893608093, 0,
                0.062003348022699356, 0.004069602582603693, 0.03322213143110275, 1,
            ],
            radius: 0.008768804371356964,
        },
        'index-finger-metacarpal': {
            offsetMatrix: [
                0.9616971015930176, -0.13805118203163147, 0.2368120402097702, 0,
                0.0005348679260350764, 0.8648636937141418, 0.5020061135292053, 0,
                -0.2741127610206604, -0.48265108466148376, 0.8318111300468445, 0,
                -0.02009812369942665, 0.008770795539021492, 0.08660387247800827, 1,
            ],
            radius: 0.021228281781077385,
        },
        'index-finger-phalanx-proximal': {
            offsetMatrix: [
                0.9001791477203369, -0.2598813474178314, 0.3494834005832672, 0,
                0.06073702871799469, 0.8695210218429565, 0.490146666765213, 0,
                -0.4312632381916046, -0.41999316215515137, 0.7985095381736755, 0,
                -0.00017739279428496957, 0.03890012577176094, 0.039073407649993896, 1,
            ],
            radius: 0.010295259766280651,
        },
        'index-finger-phalanx-intermediate': {
            offsetMatrix: [
                0.9082008600234985, -0.20898112654685974, 0.36262574791908264, 0,
                0.11045389622449875, 0.9553793668746948, 0.27395179867744446, 0,
                -0.40369608998298645, -0.20874978601932526, 0.8907597661018372, 0,
                0.01617925800383091, 0.05482936650514603, 0.008788082748651505, 1,
            ],
            radius: 0.00853810179978609,
        },
        'index-finger-phalanx-distal': {
            offsetMatrix: [
                0.9309692978858948, -0.16783711314201355, 0.32423174381256104, 0,
                0.1080828532576561, 0.9749603867530823, 0.1943446695804596, 0,
                -0.34873148798942566, -0.14588497579097748, 0.9257990717887878, 0,
                0.02599053829908371, 0.059902746230363846, -0.012860597111284733, 1,
            ],
            radius: 0.007636196445673704,
        },
        'index-finger-tip': {
            offsetMatrix: [
                0.9309692978858948, -0.16783711314201355, 0.32423174381256104, 0,
                0.1080828532576561, 0.9749603867530823, 0.1943446695804596, 0,
                -0.34873148798942566, -0.14588497579097748, 0.9257990717887878, 0,
                0.03362493962049484, 0.06421422213315964, -0.033461250364780426, 1,
            ],
            radius: 0.006636196281760931,
        },
        'middle-finger-metacarpal': {
            offsetMatrix: [
                0.9616971015930176, -0.13805118203163147, 0.2368120402097702, 0,
                0.0005348679260350764, 0.8648636937141418, 0.5020061135292053, 0,
                -0.2741127610206604, -0.48265108466148376, 0.8318111300468445, 0,
                -0.03627845644950867, 0.011579737067222595, 0.08550142496824265, 1,
            ],
            radius: 0.021231964230537415,
        },
        'middle-finger-phalanx-proximal': {
            offsetMatrix: [
                0.9876697659492493, -0.06786545366048813, 0.1410750150680542, 0,
                -0.015095947310328484, 0.855663537979126, 0.5173118710517883, 0,
                -0.15582047402858734, -0.5130629539489746, 0.8440889716148376, 0,
                -0.021259509027004242, 0.04587256908416748, 0.03659208118915558, 1,
            ],
            radius: 0.01117393933236599,
        },
        'middle-finger-phalanx-intermediate': {
            offsetMatrix: [
                0.988391637802124, -0.04354291781783104, 0.14555205404758453, 0,
                0.008894841186702251, 0.9729899168014526, 0.23067504167556763, 0,
                -0.15166506171226501, -0.22670257091522217, 0.9620829224586487, 0,
                -0.014570588245987892, 0.06789684295654297, 0.0003578895702958107, 1,
            ],
            radius: 0.008030958473682404,
        },
        'middle-finger-phalanx-distal': {
            offsetMatrix: [
                0.9853697419166565, 0.044260796159505844, 0.16458062827587128, 0,
                -0.0757969319820404, 0.9787378311157227, 0.19059516489505768, 0,
                -0.1526455283164978, -0.20028135180473328, 0.9677740931510925, 0,
                -0.010392282158136368, 0.07414241135120392, -0.026147106662392616, 1,
            ],
            radius: 0.007629410829395056,
        },
        'middle-finger-tip': {
            offsetMatrix: [
                0.9853697419166565, 0.044260796159505844, 0.16458062827587128, 0,
                -0.0757969319820404, 0.9787378311157227, 0.19059516489505768, 0,
                -0.1526455283164978, -0.20028135180473328, 0.9677740931510925, 0,
                -0.0069718430750072, 0.08024183660745621, -0.05014154314994812, 1,
            ],
            radius: 0.006629410665482283,
        },
        'ring-finger-metacarpal': {
            offsetMatrix: [
                0.9616971015930176, -0.13805118203163147, 0.2368120402097702, 0,
                0.0005348679260350764, 0.8648636937141418, 0.5020061135292053, 0,
                -0.2741127610206604, -0.48265108466148376, 0.8318111300468445, 0,
                -0.05402477830648422, 0.015797706320881844, 0.08152295649051666, 1,
            ],
            radius: 0.019088275730609894,
        },
        'ring-finger-phalanx-proximal': {
            offsetMatrix: [
                0.9940828680992126, 0.05735103040933609, 0.09224652498960495, 0,
                -0.10022822767496109, 0.8116500377655029, 0.5754809379577637, 0,
                -0.041867565363645554, -0.5813214182853699, 0.8125960826873779, 0,
                -0.041623555123806, 0.04171867296099663, 0.03582974523305893, 1,
            ],
            radius: 0.00992213748395443,
        },
        'ring-finger-phalanx-intermediate': {
            offsetMatrix: [
                0.9843675494194031, 0.12044742703437805, 0.12850022315979004, 0,
                -0.15629759430885315, 0.9337108135223389, 0.3221098482608795, 0,
                -0.08118485659360886, -0.3371586799621582, 0.937940776348114, 0,
                -0.039990875869989395, 0.06438793987035751, 0.004141641780734062, 1,
            ],
            radius: 0.007611672393977642,
        },
        'ring-finger-phalanx-distal': {
            offsetMatrix: [
                0.9748351573944092, 0.11857274919748306, 0.18877571821212769, 0,
                -0.15575434267520905, 0.9681083559989929, 0.19623035192489624, 0,
                -0.15948788821697235, -0.22069483995437622, 0.9622148275375366, 0,
                -0.03783353418111801, 0.07334739714860916, -0.020782606676220894, 1,
            ],
            radius: 0.007231088820844889,
        },
        'ring-finger-tip': {
            offsetMatrix: [
                0.9748351573944092, 0.11857274919748306, 0.18877571821212769, 0,
                -0.15575434267520905, 0.9681083559989929, 0.19623035192489624, 0,
                -0.15948788821697235, -0.22069483995437622, 0.9622148275375366, 0,
                -0.03445569798350334, 0.0802423357963562, -0.04392268508672714, 1,
            ],
            radius: 0.0062310886569321156,
        },
        'pinky-finger-metacarpal': {
            offsetMatrix: [
                0.9181402921676636, 0.35625091195106506, 0.17350243031978607, 0,
                -0.39615097641944885, 0.8352503180503845, 0.38134080171585083, 0,
                -0.009065053425729275, -0.41885748505592346, 0.9080066680908203, 0,
                -0.06191859766840935, 0.013620133511722088, 0.07850203663110733, 1,
            ],
            radius: 0.01808827556669712,
        },
        'pinky-finger-phalanx-proximal': {
            offsetMatrix: [
                0.9714386463165283, 0.236698180437088, -0.016745081171393394, 0,
                -0.18462024629116058, 0.7982627749443054, 0.5733163952827454, 0,
                0.14906984567642212, -0.5538501739501953, 0.8191629648208618, 0,
                -0.061502378433942795, 0.032741155475378036, 0.03705105185508728, 1,
            ],
            radius: 0.008483353070914745,
        },
        'pinky-finger-phalanx-intermediate': {
            offsetMatrix: [
                0.9337416291236877, 0.35620439052581787, -0.03527557849884033, 0,
                -0.33203884959220886, 0.8987522721290588, 0.28634607791900635, 0,
                0.13370157778263092, -0.2556603252887726, 0.9574766755104065, 0,
                -0.06608185172080994, 0.049755651503801346, 0.011886020191013813, 1,
            ],
            radius: 0.0067641944624483585,
        },
        'pinky-finger-phalanx-distal': {
            offsetMatrix: [
                0.9419984817504883, 0.3303581774234772, 0.059175245463848114, 0,
                -0.33483216166496277, 0.9130291938781738, 0.23294763267040253, 0,
                0.02292730286717415, -0.2392500638961792, 0.970687210559845, 0,
                -0.0687975287437439, 0.054948460310697556, -0.007561664097011089, 1,
            ],
            radius: 0.0064259846694767475,
        },
        'pinky-finger-tip': {
            offsetMatrix: [
                0.9419984817504883, 0.3303581774234772, 0.059175245463848114, 0,
                -0.33483216166496277, 0.9130291938781738, 0.23294763267040253, 0,
                0.02292730286717415, -0.2392500638961792, 0.970687210559845, 0,
                -0.06947512179613113, 0.0613851435482502, -0.028543535619974136, 1,
            ],
            radius: 0.005425984505563974,
        },
    },
    gripOffsetMatrix: [
        -0.0005348679260350764, -0.8648636937141418, -0.5020061135292053, 0,
        -0.2741127908229828, -0.48265108466148376, 0.8318111896514893, 0,
        -0.9616971015930176, 0.13805119693279266, -0.2368120402097702, 0,
        -0.02878567762672901, 0.0017147823236882687, 0.04536811262369156, 1,
    ],
};

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const oculusHandConfig = {
    profileId: 'oculus-hand',
    fallbackProfileIds: [
        'generic-hand',
        'generic-hand-select',
        'generic-trigger',
    ],
    poses: {
        default: relaxedHandPose,
        pinch: pinchHandPose,
        point: pointHandPose,
    },
};
const XRHandGamepadConfig = {
    mapping: GamepadMappingType.None,
    buttons: [{ id: 'pinch', type: 'analog', eventTrigger: 'select' }],
    axes: [],
};
const fromPosition = create$2();
const fromQuaternion = create();
const fromScale = create$2();
const toPosition = create$2();
const toQuaternion = create();
const toScale = create$2();
const interpolatedPosition = create$2();
const interpolatedQuaternion = create();
const interpolatedScale = create$2();
const interpolateMatrix = (out, fromMatrix, toMatrix, alpha) => {
    getTranslation(fromPosition, fromMatrix);
    getRotation(fromQuaternion, fromMatrix);
    getScaling(fromScale, fromMatrix);
    getTranslation(toPosition, toMatrix);
    getRotation(toQuaternion, toMatrix);
    getScaling(toScale, toMatrix);
    lerp(interpolatedPosition, fromPosition, toPosition, alpha);
    slerp(interpolatedQuaternion, fromQuaternion, toQuaternion, alpha);
    lerp(interpolatedScale, fromScale, toScale, alpha);
    fromRotationTranslationScale(out, interpolatedQuaternion, interpolatedPosition, interpolatedScale);
    return out;
};
const mirrorMultiplierMatrix = [
    1, -1, -1, 0, -1, 1, 1, 0, -1, 1, 1, 0, -1, 1, 1, 1,
];
const mirrorMatrixToRight = (matrixLeft) => {
    for (let i = 0; i < 16; i++) {
        matrixLeft[i] *= mirrorMultiplierMatrix[i];
    }
};
const PRIVATE$5 = Symbol('@immersive-web-emulation-runtime/xr-hand-input');
class XRHandInput extends XRTrackedInput {
    constructor(handInputConfig, handedness, globalSpace) {
        if (handedness !== XRHandedness.Left && handedness !== XRHandedness.Right) {
            throw new DOMException('handedness for XRHandInput must be either "left" or "right"', 'InvalidStateError');
        }
        if (!handInputConfig.poses.default || !handInputConfig.poses.pinch) {
            throw new DOMException('"default" and "pinch" hand pose configs are required', 'InvalidStateError');
        }
        const targetRaySpace = new XRSpace(globalSpace);
        const gripSpace = new XRSpace(targetRaySpace);
        const profiles = [
            handInputConfig.profileId,
            ...handInputConfig.fallbackProfileIds,
        ];
        const hand = new XRHand();
        Object.values(XRHandJoint).forEach((jointName) => {
            hand.set(jointName, new XRJointSpace(jointName, targetRaySpace));
        });
        const inputSource = new XRInputSource(handedness, XRTargetRayMode.TrackedPointer, profiles, targetRaySpace, new Gamepad(XRHandGamepadConfig), gripSpace, hand);
        super(inputSource);
        this[PRIVATE$5] = {
            poseId: 'default',
            poses: handInputConfig.poses,
        };
        this.updateHandPose();
    }
    get poseId() {
        return this[PRIVATE$5].poseId;
    }
    set poseId(poseId) {
        if (!this[PRIVATE$5].poses[poseId]) {
            console.warn(`Pose config ${poseId} not found`);
            return;
        }
        this[PRIVATE$5].poseId = poseId;
    }
    updateHandPose() {
        const targetPose = this[PRIVATE$5].poses[this[PRIVATE$5].poseId];
        const pinchPose = this[PRIVATE$5].poses.pinch;
        Object.values(XRHandJoint).forEach((jointName) => {
            const targetJointMatrix = targetPose.jointTransforms[jointName].offsetMatrix;
            const pinchJointMatrix = pinchPose.jointTransforms[jointName].offsetMatrix;
            const jointSpace = this.inputSource.hand.get(jointName);
            interpolateMatrix(jointSpace[PRIVATE$l].offsetMatrix, targetJointMatrix, pinchJointMatrix, this.pinchValue);
            if (this.inputSource.handedness === XRHandedness.Right) {
                mirrorMatrixToRight(jointSpace[PRIVATE$l].offsetMatrix);
            }
            jointSpace[PRIVATE$f].radius =
                (1 - this.pinchValue) * targetPose.jointTransforms[jointName].radius +
                    this.pinchValue * pinchPose.jointTransforms[jointName].radius;
        });
        if (targetPose.gripOffsetMatrix && pinchPose.gripOffsetMatrix) {
            interpolateMatrix(this.inputSource.gripSpace[PRIVATE$l].offsetMatrix, targetPose.gripOffsetMatrix, pinchPose.gripOffsetMatrix, this.pinchValue);
        }
    }
    get pinchValue() {
        return this[PRIVATE$i].inputSource.gamepad[PRIVATE$k]
            .buttonsMap['pinch'].value;
    }
    updatePinchValue(value) {
        if (value > 1 || value < 0) {
            console.warn(`Out-of-range value ${value} provided for pinch`);
            return;
        }
        const gamepadButton = this[PRIVATE$i].inputSource.gamepad[PRIVATE$k]
            .buttonsMap['pinch'];
        gamepadButton[PRIVATE$k].pendingValue = value;
    }
    onFrameStart(frame) {
        super.onFrameStart(frame);
        this.updateHandPose();
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const PRIVATE$4 = Symbol('@immersive-web-emulation-runtime/xr-system');
class XRSystem extends EventTarget {
    constructor(device) {
        super();
        this[PRIVATE$4] = { device };
        // Initialize device change monitoring here if applicable
    }
    isSessionSupported(mode) {
        return new Promise((resolve, _reject) => {
            if (mode === XRSessionMode.Inline) {
                resolve(true);
            }
            else {
                // Check for spatial tracking permission if necessary
                resolve(this[PRIVATE$4].device.supportedSessionModes.includes(mode));
            }
        });
    }
    requestSession(mode, options = {}) {
        return new Promise((resolve, reject) => {
            this.isSessionSupported(mode)
                .then((isSupported) => {
                if (!isSupported) {
                    reject(new DOMException('The requested XRSession mode is not supported.', 'NotSupportedError'));
                    return;
                }
                // Check for active sessions and other constraints here
                if (this[PRIVATE$4].activeSession) {
                    reject(new DOMException('An active XRSession already exists.', 'InvalidStateError'));
                    return;
                }
                // Handle required and optional features
                const { requiredFeatures = [], optionalFeatures = [] } = options;
                const { supportedFeatures } = this[PRIVATE$4].device;
                // Check if all required features are supported
                const allRequiredSupported = requiredFeatures.every((feature) => supportedFeatures.includes(feature));
                if (!allRequiredSupported) {
                    reject(new Error('One or more required features are not supported by the device.'));
                    return;
                }
                // Filter out unsupported optional features
                const supportedOptionalFeatures = optionalFeatures.filter((feature) => supportedFeatures.includes(feature));
                // Combine required and supported optional features into enabled features
                const enabledFeatures = Array.from(new Set([
                    ...requiredFeatures,
                    ...supportedOptionalFeatures,
                    WebXRFeatures.Viewer,
                    WebXRFeatures.Local,
                ]));
                // Proceed with session creation
                const session = new XRSession(this[PRIVATE$4].device, mode, enabledFeatures);
                this[PRIVATE$4].activeSession = session;
                // Listen for session end to clear the active session
                session.addEventListener('end', () => {
                    this[PRIVATE$4].activeSession = undefined;
                });
                resolve(session);
            })
                .catch(reject);
        });
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const PRIVATE$3 = Symbol('@immersive-web-emulation-runtime/action-player');
class ActionPlayer {
    constructor(refSpace, recording, ipd) {
        const { schema, frames } = recording;
        if (!frames || !schema || frames.length === 0) {
            throw new DOMException('wrong recording format', 'NotSupportedError');
        }
        const viewerSpace = new XRReferenceSpace(XRReferenceSpaceType.Viewer, refSpace);
        const viewSpaces = {
            [XREye.Left]: new XRSpace(viewerSpace),
            [XREye.Right]: new XRSpace(viewerSpace),
            [XREye.None]: new XRSpace(viewerSpace),
        };
        this[PRIVATE$3] = {
            refSpace,
            inputSources: new Map(),
            inputSchemas: new Map(),
            frames,
            recordedFramePointer: 0,
            startingTimeStamp: frames[0][0],
            endingTimeStamp: frames[frames.length - 1][0],
            playbackTime: frames[0][0],
            playing: false,
            viewerSpace,
            viewSpaces,
            vec3: create$2(),
            quat: create(),
        };
        fromTranslation(this[PRIVATE$3].viewSpaces[XREye.Left][PRIVATE$l].offsetMatrix, fromValues$2(-ipd / 2, 0, 0));
        fromTranslation(this[PRIVATE$3].viewSpaces[XREye.Right][PRIVATE$l].offsetMatrix, fromValues$2(ipd / 2, 0, 0));
        schema.forEach((schemaEntry) => {
            const index = schemaEntry[0];
            const schema = schemaEntry[1];
            let gamepad;
            if (schema.hasGamepad) {
                const buttons = [];
                for (let i = 0; i < schema.numButtons; i++) {
                    buttons.push({ id: i.toString(), type: 'manual' });
                }
                const axes = [];
                for (let i = 0; i < schema.numAxes; i++) {
                    axes.push({ id: i.toString(), type: 'manual' });
                }
                gamepad = new Gamepad({
                    mapping: schema.mapping,
                    buttons,
                    axes,
                });
            }
            const targetRaySpace = new XRSpace(refSpace);
            let hand = undefined;
            if (schema.hasHand) {
                hand = new XRHand();
                Object.values(XRHandJoint).forEach((jointName) => {
                    hand.set(jointName, new XRJointSpace(jointName, targetRaySpace));
                });
            }
            const inputSource = new XRInputSource(schema.handedness, schema.targetRayMode, schema.profiles, targetRaySpace, gamepad, schema.hasGrip ? new XRSpace(refSpace) : undefined, schema.hasHand ? hand : undefined);
            this[PRIVATE$3].inputSources.set(index, {
                active: false,
                source: inputSource,
            });
            this[PRIVATE$3].inputSchemas.set(index, schema);
        });
    }
    play() {
        this[PRIVATE$3].recordedFramePointer = 0;
        this[PRIVATE$3].playbackTime = this[PRIVATE$3].startingTimeStamp;
        this[PRIVATE$3].playing = true;
        this[PRIVATE$3].actualTimeStamp = performance.now();
    }
    stop() {
        this[PRIVATE$3].playing = false;
    }
    get playing() {
        return this[PRIVATE$3].playing;
    }
    get viewerSpace() {
        return this[PRIVATE$3].viewerSpace;
    }
    get viewSpaces() {
        return this[PRIVATE$3].viewSpaces;
    }
    get inputSources() {
        return Array.from(this[PRIVATE$3].inputSources.values())
            .filter((wrapper) => wrapper.active)
            .map((wrapper) => wrapper.source);
    }
    playFrame() {
        const now = performance.now();
        const delta = now - this[PRIVATE$3].actualTimeStamp;
        this[PRIVATE$3].actualTimeStamp = now;
        this[PRIVATE$3].playbackTime += delta;
        if (this[PRIVATE$3].playbackTime > this[PRIVATE$3].endingTimeStamp) {
            this.stop();
            return;
        }
        while (this[PRIVATE$3].frames[this[PRIVATE$3].recordedFramePointer + 1][0] < this[PRIVATE$3].playbackTime) {
            this[PRIVATE$3].recordedFramePointer++;
        }
        const lastFrameData = this[PRIVATE$3].frames[this[PRIVATE$3].recordedFramePointer];
        const nextFrameData = this[PRIVATE$3].frames[this[PRIVATE$3].recordedFramePointer + 1];
        const alpha = (this[PRIVATE$3].playbackTime - lastFrameData[0]) /
            (nextFrameData[0] - lastFrameData[0]);
        this.updateXRSpaceFromMergedFrames(this[PRIVATE$3].viewerSpace, lastFrameData.slice(1, 8), nextFrameData.slice(1, 8), alpha);
        const lastFrameInputs = new Map();
        for (let i = 8; i < lastFrameData.length; i++) {
            const { index, inputData } = this.processRawInputData(lastFrameData[i]);
            lastFrameInputs.set(index, inputData);
        }
        const nextFrameInputs = new Map();
        for (let i = 8; i < nextFrameData.length; i++) {
            const { index, inputData } = this.processRawInputData(nextFrameData[i]);
            nextFrameInputs.set(index, inputData);
        }
        this[PRIVATE$3].inputSources.forEach((sourceWrapper) => {
            sourceWrapper.active = false;
        });
        nextFrameInputs.forEach((inputData, index) => {
            this[PRIVATE$3].inputSources.get(index).active = true;
            const inputSource = this[PRIVATE$3].inputSources.get(index).source;
            const schema = this[PRIVATE$3].inputSchemas.get(index);
            this.updateInputSource(inputSource, schema, lastFrameInputs.has(index) ? lastFrameInputs.get(index) : inputData, inputData, alpha);
        });
    }
    updateInputSource(inputSource, schema, lastInputData, nextInputData, alpha) {
        this.updateXRSpaceFromMergedFrames(inputSource.targetRaySpace, lastInputData.targetRayTransform, nextInputData.targetRayTransform, alpha);
        if (schema.hasGrip) {
            this.updateXRSpaceFromMergedFrames(inputSource.gripSpace, lastInputData.gripTransform, nextInputData.gripTransform, alpha);
        }
        if (schema.hasHand) {
            for (let i = 0; i < 25; i++) {
                const lastTransformArray = lastInputData.handTransforms.slice(i * 8, i * 8 + 7);
                const nextTransformArray = nextInputData.handTransforms.slice(i * 8, i * 8 + 7);
                const lastRadius = lastInputData.handTransforms[i * 8 + 7];
                const nextRadius = nextInputData.handTransforms[i * 8 + 7];
                const jointSpace = inputSource.hand.get(schema.jointSequence[i]);
                this.updateXRSpaceFromMergedFrames(jointSpace, lastTransformArray, nextTransformArray, alpha);
                jointSpace[PRIVATE$f].radius =
                    (nextRadius - lastRadius) * alpha + lastRadius;
            }
        }
        if (schema.hasGamepad) {
            const gamepad = inputSource.gamepad;
            nextInputData.buttons.forEach((states, index) => {
                const gamepadButton = gamepad.buttons[index];
                gamepadButton[PRIVATE$k].pressed = states[0] === 1 ? true : false;
                gamepadButton[PRIVATE$k].touched = states[1] === 1 ? true : false;
                const lastValue = lastInputData.buttons[index][2];
                const nextValue = states[2];
                gamepadButton[PRIVATE$k].value =
                    (nextValue - lastValue) * alpha + lastValue;
            });
            nextInputData.axes.forEach((nextValue, index) => {
                const lastValue = lastInputData.axes[index];
                gamepad[PRIVATE$k].axesMap[index.toString()].x =
                    (nextValue - lastValue) * alpha + lastValue;
            });
        }
    }
    updateXRSpaceFromMergedFrames(space, lastTransform, nextTransform, alpha) {
        const f1p = fromValues$2(lastTransform[0], lastTransform[1], lastTransform[2]);
        const f1q = fromValues(lastTransform[3], lastTransform[4], lastTransform[5], lastTransform[6]);
        const f2p = fromValues$2(nextTransform[0], nextTransform[1], nextTransform[2]);
        const f2q = fromValues(nextTransform[3], nextTransform[4], nextTransform[5], nextTransform[6]);
        lerp(this[PRIVATE$3].vec3, f1p, f2p, alpha);
        slerp(this[PRIVATE$3].quat, f1q, f2q, alpha);
        fromRotationTranslation(space[PRIVATE$l].offsetMatrix, this[PRIVATE$3].quat, this[PRIVATE$3].vec3);
    }
    processRawInputData(inputDataRaw) {
        const index = inputDataRaw[0];
        const schema = this[PRIVATE$3].inputSchemas.get(index);
        const targetRayTransform = inputDataRaw.slice(1, 8);
        const inputData = { targetRayTransform };
        let dataCounter = 8;
        if (schema.hasGrip) {
            inputData.gripTransform = inputDataRaw[dataCounter++];
        }
        if (schema.hasHand) {
            inputData.handTransforms = inputDataRaw[dataCounter++];
        }
        if (schema.hasGamepad) {
            const gamepadData = inputDataRaw[dataCounter];
            inputData.buttons = gamepadData.slice(0, schema.numButtons);
            inputData.axes = gamepadData.slice(schema.numButtons);
        }
        return { index, inputData };
    }
}

const VERSION = "1.0.4";

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
class XRReferenceSpaceEvent extends Event {
    constructor(type, eventInitDict) {
        super(type, eventInitDict);
        if (!eventInitDict.referenceSpace) {
            throw new Error('XRReferenceSpaceEventInit.referenceSpace is required');
        }
        this.referenceSpace = eventInitDict.referenceSpace;
        this.transform = eventInitDict.transform;
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const PRIVATE$2 = Symbol('@immersive-web-emulation-runtime/xr-viewport');
class XRViewport {
    constructor(x, y, width, height) {
        this[PRIVATE$2] = { x, y, width, height };
    }
    get x() {
        return this[PRIVATE$2].x;
    }
    get y() {
        return this[PRIVATE$2].y;
    }
    get width() {
        return this[PRIVATE$2].width;
    }
    get height() {
        return this[PRIVATE$2].height;
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var WebXRFeatures;
(function (WebXRFeatures) {
    WebXRFeatures["Viewer"] = "viewer";
    WebXRFeatures["Local"] = "local";
    WebXRFeatures["LocalFloor"] = "local-floor";
    WebXRFeatures["BoundedFloor"] = "bounded-floor";
    WebXRFeatures["Unbounded"] = "unbounded";
    WebXRFeatures["DomOverlay"] = "dom-overlay";
    WebXRFeatures["Anchors"] = "anchors";
    WebXRFeatures["PlaneDetection"] = "plane-detection";
    WebXRFeatures["MeshDetection"] = "mesh-detection";
    WebXRFeatures["HitTest"] = "hit-test";
    WebXRFeatures["HandTracking"] = "hand-tracking";
    WebXRFeatures["DepthSensing"] = "depth-sensing";
})(WebXRFeatures || (WebXRFeatures = {}));
const PRIVATE$1 = Symbol('@immersive-web-emulation-runtime/xr-device');
const DEFAULTS = {
    ipd: 0.063,
    fovy: Math.PI / 2,
    headsetPosition: new Vector3(0, 1.6, 0),
    headsetQuaternion: new Quaternion(),
    stereoEnabled: false,
};
/**
 * XRDevice is not a standard API class outlined in the WebXR Device API Specifications
 * Instead, it serves as an user-facing interface to control the emulated XR Device
 */
class XRDevice {
    constructor(deviceConfig, deviceOptions = {}) {
        var _a, _b, _c, _d, _e, _f;
        const globalSpace = new GlobalSpace();
        const viewerSpace = new XRReferenceSpace(XRReferenceSpaceType.Viewer, globalSpace);
        const viewSpaces = {
            [XREye.Left]: new XRSpace(viewerSpace),
            [XREye.Right]: new XRSpace(viewerSpace),
            [XREye.None]: new XRSpace(viewerSpace),
        };
        const controllerConfig = deviceConfig.controllerConfig;
        const controllers = {};
        if (controllerConfig) {
            Object.values(XRHandedness).forEach((handedness) => {
                if (controllerConfig.layout[handedness]) {
                    controllers[handedness] = new XRController(controllerConfig, handedness, globalSpace);
                }
            });
        }
        const hands = {
            [XRHandedness.Left]: new XRHandInput(oculusHandConfig, XRHandedness.Left, globalSpace),
            [XRHandedness.Right]: new XRHandInput(oculusHandConfig, XRHandedness.Right, globalSpace),
        };
        const canvasContainer = (_a = deviceOptions.canvasContainer) !== null && _a !== void 0 ? _a : document.createElement('div');
        canvasContainer.dataset.webxr_runtime = `Immersive Web Emulation Runtime v${VERSION}`;
        canvasContainer.style.position = 'fixed';
        canvasContainer.style.width = '100%';
        canvasContainer.style.height = '100%';
        canvasContainer.style.top = '0';
        canvasContainer.style.left = '0';
        canvasContainer.style.display = 'flex';
        canvasContainer.style.justifyContent = 'center';
        canvasContainer.style.alignItems = 'center';
        canvasContainer.style.overflow = 'hidden';
        canvasContainer.style.zIndex = '999';
        this[PRIVATE$1] = {
            name: deviceConfig.name,
            supportedSessionModes: deviceConfig.supportedSessionModes,
            supportedFeatures: deviceConfig.supportedFeatures,
            supportedFrameRates: deviceConfig.supportedFrameRates,
            isSystemKeyboardSupported: deviceConfig.isSystemKeyboardSupported,
            internalNominalFrameRate: deviceConfig.internalNominalFrameRate,
            environmentBlendModes: deviceConfig.environmentBlendModes,
            interactionMode: deviceConfig.interactionMode,
            userAgent: deviceConfig.userAgent,
            position: (_b = deviceOptions.headsetPosition) !== null && _b !== void 0 ? _b : DEFAULTS.headsetPosition.clone(),
            quaternion: (_c = deviceOptions.headsetQuaternion) !== null && _c !== void 0 ? _c : DEFAULTS.headsetQuaternion.clone(),
            stereoEnabled: (_d = deviceOptions.stereoEnabled) !== null && _d !== void 0 ? _d : DEFAULTS.stereoEnabled,
            ipd: (_e = deviceOptions.ipd) !== null && _e !== void 0 ? _e : DEFAULTS.ipd,
            fovy: (_f = deviceOptions.fovy) !== null && _f !== void 0 ? _f : DEFAULTS.fovy,
            controllers,
            hands,
            primaryInputMode: 'controller',
            pendingReferenceSpaceReset: false,
            visibilityState: XRVisibilityState.Visible,
            pendingVisibilityState: null,
            xrSystem: null,
            matrix: create$3(),
            globalSpace,
            viewerSpace,
            viewSpaces,
            canvasContainer,
            getViewport: (layer, view) => {
                const canvas = layer.context.canvas;
                const { width, height } = canvas;
                switch (view.eye) {
                    case XREye.None:
                        return new XRViewport(0, 0, width, height);
                    case XREye.Left:
                        return new XRViewport(0, 0, this[PRIVATE$1].stereoEnabled ? width / 2 : width, height);
                    case XREye.Right:
                        return new XRViewport(width / 2, 0, this[PRIVATE$1].stereoEnabled ? width / 2 : 0, height);
                }
            },
            updateViews: () => {
                // update viewerSpace
                const viewerSpace = this[PRIVATE$1].viewerSpace;
                fromRotationTranslation(viewerSpace[PRIVATE$l].offsetMatrix, this[PRIVATE$1].quaternion.quat, this[PRIVATE$1].position.vec3);
                // update viewSpaces
                fromTranslation(this[PRIVATE$1].viewSpaces[XREye.Left][PRIVATE$l].offsetMatrix, fromValues$2(-this[PRIVATE$1].ipd / 2, 0, 0));
                fromTranslation(this[PRIVATE$1].viewSpaces[XREye.Right][PRIVATE$l].offsetMatrix, fromValues$2(this[PRIVATE$1].ipd / 2, 0, 0));
            },
            onBaseLayerSet: (baseLayer) => {
                if (!baseLayer)
                    return;
                // backup canvas data
                const canvas = baseLayer.context.canvas;
                if (canvas.parentElement !== this[PRIVATE$1].canvasContainer) {
                    this[PRIVATE$1].canvasData = {
                        canvas,
                        parent: canvas.parentElement,
                        width: canvas.width,
                        height: canvas.height,
                    };
                    this[PRIVATE$1].canvasContainer.appendChild(canvas);
                    document.body.appendChild(this[PRIVATE$1].canvasContainer);
                }
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            },
            onSessionEnd: () => {
                if (this[PRIVATE$1].canvasData) {
                    const { canvas, parent, width, height } = this[PRIVATE$1].canvasData;
                    canvas.width = width;
                    canvas.height = height;
                    if (parent) {
                        parent.appendChild(canvas);
                    }
                    else {
                        this[PRIVATE$1].canvasContainer.removeChild(canvas);
                    }
                    document.body.removeChild(this[PRIVATE$1].canvasContainer);
                    window.dispatchEvent(new Event('resize'));
                }
            },
            onFrameStart: (frame) => {
                var _a;
                if ((_a = this[PRIVATE$1].actionPlayer) === null || _a === void 0 ? void 0 : _a.playing) {
                    this[PRIVATE$1].actionPlayer.playFrame();
                }
                else {
                    const session = frame.session;
                    this[PRIVATE$1].updateViews();
                    if (this[PRIVATE$1].pendingVisibilityState) {
                        this[PRIVATE$1].visibilityState =
                            this[PRIVATE$1].pendingVisibilityState;
                        this[PRIVATE$1].pendingVisibilityState = null;
                        session.dispatchEvent(new XRSessionEvent('visibilitychange', { session }));
                    }
                    if (this[PRIVATE$1].visibilityState === XRVisibilityState.Visible) {
                        this.activeInputs.forEach((activeInput) => {
                            activeInput.onFrameStart(frame);
                        });
                    }
                    if (this[PRIVATE$1].pendingReferenceSpaceReset) {
                        session[PRIVATE$6].referenceSpaces.forEach((referenceSpace) => {
                            switch (referenceSpace[PRIVATE$9].type) {
                                case XRReferenceSpaceType.Local:
                                case XRReferenceSpaceType.LocalFloor:
                                case XRReferenceSpaceType.BoundedFloor:
                                case XRReferenceSpaceType.Unbounded:
                                    referenceSpace.dispatchEvent(new XRReferenceSpaceEvent('reset', { referenceSpace }));
                                    break;
                            }
                        });
                        this[PRIVATE$1].pendingReferenceSpaceReset = false;
                    }
                }
                this[PRIVATE$1].updateViews();
            },
        };
        this[PRIVATE$1].updateViews();
    }
    installRuntime(globalObject = globalThis) {
        Object.defineProperty(WebGL2RenderingContext.prototype, 'makeXRCompatible', {
            value: function () {
                return new Promise((resolve, _reject) => {
                    resolve(true);
                });
            },
            configurable: true,
        });
        this[PRIVATE$1].xrSystem = new XRSystem(this);
        Object.defineProperty(globalThis.navigator, 'xr', {
            value: this[PRIVATE$1].xrSystem,
            configurable: true,
        });
        Object.defineProperty(navigator, 'userAgent', {
            value: this[PRIVATE$1].userAgent,
            writable: false,
            configurable: false,
            enumerable: true,
        });
        globalObject['XRSystem'] = XRSystem;
        globalObject['XRSession'] = XRSession;
        globalObject['XRRenderState'] = XRRenderState;
        globalObject['XRFrame'] = XRFrame;
        globalObject['XRSpace'] = XRSpace;
        globalObject['XRReferenceSpace'] = XRReferenceSpace;
        globalObject['XRJointSpace'] = XRJointSpace;
        globalObject['XRView'] = XRView;
        globalObject['XRViewport'] = XRViewport;
        globalObject['XRRigidTransform'] = XRRigidTransform;
        globalObject['XRPose'] = XRPose;
        globalObject['XRViewerPose'] = XRViewerPose;
        globalObject['XRJointPose'] = XRJointPose;
        globalObject['XRInputSource'] = XRInputSource;
        globalObject['XRInputSourceArray'] = XRInputSourceArray;
        globalObject['XRHand'] = XRHand;
        globalObject['XRLayer'] = XRLayer;
        globalObject['XRWebGLLayer'] = XRWebGLLayer;
        globalObject['XRSessionEvent'] = XRSessionEvent;
        globalObject['XRInputSourceEvent'] = XRInputSourceEvent;
        globalObject['XRInputSourcesChangeEvent'] = XRInputSourcesChangeEvent;
        globalObject['XRReferenceSpaceEvent'] = XRReferenceSpaceEvent;
    }
    get supportedSessionModes() {
        return this[PRIVATE$1].supportedSessionModes;
    }
    get supportedFeatures() {
        return this[PRIVATE$1].supportedFeatures;
    }
    get supportedFrameRates() {
        return this[PRIVATE$1].supportedFrameRates;
    }
    get isSystemKeyboardSupported() {
        return this[PRIVATE$1].isSystemKeyboardSupported;
    }
    get internalNominalFrameRate() {
        return this[PRIVATE$1].internalNominalFrameRate;
    }
    get stereoEnabled() {
        return this[PRIVATE$1].stereoEnabled;
    }
    set stereoEnabled(value) {
        this[PRIVATE$1].stereoEnabled = value;
    }
    get ipd() {
        return this[PRIVATE$1].ipd;
    }
    set ipd(value) {
        this[PRIVATE$1].ipd = value;
    }
    get fovy() {
        return this[PRIVATE$1].fovy;
    }
    set fovy(value) {
        this[PRIVATE$1].fovy = value;
    }
    get position() {
        return this[PRIVATE$1].position;
    }
    get quaternion() {
        return this[PRIVATE$1].quaternion;
    }
    get viewerSpace() {
        var _a;
        if ((_a = this[PRIVATE$1].actionPlayer) === null || _a === void 0 ? void 0 : _a.playing) {
            return this[PRIVATE$1].actionPlayer.viewerSpace;
        }
        else {
            return this[PRIVATE$1].viewerSpace;
        }
    }
    get viewSpaces() {
        var _a;
        if ((_a = this[PRIVATE$1].actionPlayer) === null || _a === void 0 ? void 0 : _a.playing) {
            return this[PRIVATE$1].actionPlayer.viewSpaces;
        }
        else {
            return this[PRIVATE$1].viewSpaces;
        }
    }
    get controllers() {
        return this[PRIVATE$1].controllers;
    }
    get hands() {
        return this[PRIVATE$1].hands;
    }
    get primaryInputMode() {
        return this[PRIVATE$1].primaryInputMode;
    }
    set primaryInputMode(mode) {
        if (mode !== 'controller' && mode !== 'hand') {
            console.warn('primary input mode can only be "controller" or "hand"');
            return;
        }
        this[PRIVATE$1].primaryInputMode = mode;
    }
    get activeInputs() {
        if (this[PRIVATE$1].visibilityState !== XRVisibilityState.Visible) {
            return [];
        }
        const activeInputs = this[PRIVATE$1].primaryInputMode === 'controller'
            ? Object.values(this[PRIVATE$1].controllers)
            : Object.values(this[PRIVATE$1].hands);
        return activeInputs.filter((input) => input.connected);
    }
    get inputSources() {
        var _a;
        if ((_a = this[PRIVATE$1].actionPlayer) === null || _a === void 0 ? void 0 : _a.playing) {
            return this[PRIVATE$1].actionPlayer.inputSources;
        }
        else {
            return this.activeInputs.map((input) => input.inputSource);
        }
    }
    get canvasContainer() {
        return this[PRIVATE$1].canvasContainer;
    }
    get activeSession() {
        var _a;
        return (_a = this[PRIVATE$1].xrSystem) === null || _a === void 0 ? void 0 : _a[PRIVATE$4].activeSession;
    }
    recenter() {
        const deltaVec = new Vector3(-this.position.x, 0, -this.position.z);
        const forward = new Vector3(0, 0, -1).applyQuaternion(this.quaternion);
        forward.y = 0;
        forward.normalize();
        const angle = Math.atan2(forward.x, -forward.z);
        const deltaQuat = new Quaternion().setFromAxisAngle(new Vector3(0, 1, 0), angle);
        this.position.add(deltaVec);
        this.quaternion.multiply(deltaQuat);
        [
            ...Object.values(this[PRIVATE$1].controllers),
            ...Object.values(this[PRIVATE$1].hands),
        ].forEach((activeInput) => {
            activeInput.position.add(deltaVec);
            activeInput.quaternion.multiply(deltaQuat);
            activeInput.position.applyQuaternion(deltaQuat);
        });
        this[PRIVATE$1].pendingReferenceSpaceReset = true;
    }
    get visibilityState() {
        return this[PRIVATE$1].visibilityState;
    }
    // visibility state updates are queued until the XRSession produces frames
    updateVisibilityState(state) {
        if (!Object.values(XRVisibilityState).includes(state)) {
            throw new DOMException('Invalid XRVisibilityState value', 'NotSupportedError');
        }
        if (state !== this[PRIVATE$1].visibilityState) {
            this[PRIVATE$1].pendingVisibilityState = state;
        }
    }
    createActionPlayer(refSpace, recording) {
        this[PRIVATE$1].actionPlayer = new ActionPlayer(refSpace, recording, this[PRIVATE$1].ipd);
        return this[PRIVATE$1].actionPlayer;
    }
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const gamepadConfigLeft = {
    mapping: GamepadMappingType.XRStandard,
    buttons: [
        { id: 'trigger', type: 'analog', eventTrigger: 'select' },
        { id: 'squeeze', type: 'analog', eventTrigger: 'squeeze' },
        null,
        { id: 'thumbstick', type: 'binary' },
        { id: 'x-button', type: 'binary' },
        { id: 'y-button', type: 'binary' },
        { id: 'thumbrest', type: 'binary' },
    ],
    axes: [
        null,
        null,
        { id: 'thumbstick', type: 'x-axis' },
        { id: 'thumbstick', type: 'y-axis' },
    ],
};
const gamepadConfigRight = {
    mapping: GamepadMappingType.XRStandard,
    buttons: [
        { id: 'trigger', type: 'analog', eventTrigger: 'select' },
        { id: 'squeeze', type: 'analog', eventTrigger: 'squeeze' },
        null,
        { id: 'thumbstick', type: 'binary' },
        { id: 'a-button', type: 'binary' },
        { id: 'b-button', type: 'binary' },
        { id: 'thumbrest', type: 'binary' },
    ],
    axes: [
        null,
        null,
        { id: 'thumbstick', type: 'x-axis' },
        { id: 'thumbstick', type: 'y-axis' },
    ],
};
const oculusTouchV2 = {
    profileId: 'oculus-touch-v2',
    fallbackProfileIds: ['oculus-touch', 'generic-trigger-squeeze-thumbstick'],
    layout: {
        left: {
            gamepad: gamepadConfigLeft,
            gripOffsetMatrix: [
                0.9925461411476135, 4.673031295254759e-9, -0.12186938524246216, 0,
                0.08617470413446426, 0.7071065306663513, 0.7018362283706665, 0,
                0.0861746296286583, -0.70710688829422, 0.7018358707427979, 0,
                -0.003979847766458988, -0.01585787907242775, 0.04964185878634453, 1,
            ],
            numHapticActuators: 1,
        },
        right: {
            gamepad: gamepadConfigRight,
            gripOffsetMatrix: [
                0.9925461411476135, 3.688163374704345e-8, 0.12186937034130096, 0,
                -0.08617469668388367, 0.7071066498756409, 0.7018361687660217, 0,
                -0.0861746147274971, -0.7071068286895752, 0.7018359899520874, 0,
                0.003979853354394436, -0.01585787907242775, 0.04964182525873184, 1,
            ],
            numHapticActuators: 1,
        },
    },
};
const oculusTouchV3 = {
    profileId: 'oculus-touch-v3',
    fallbackProfileIds: ['oculus-touch', 'generic-trigger-squeeze-thumbstick'],
    layout: {
        left: {
            gamepad: gamepadConfigLeft,
            gripOffsetMatrix: [
                0.9925461411476135, 2.0823669899527886e-8, -0.12186937034130096, 0,
                0.08617465198040009, 0.7071067094802856, 0.701836109161377, 0,
                0.08617466688156128, -0.7071067690849304, 0.7018360495567322, 0,
                -0.003979838453233242, -0.015857907012104988, 0.04964181408286095, 1,
            ],
            numHapticActuators: 1,
        },
        right: {
            gamepad: gamepadConfigRight,
            gripOffsetMatrix: [
                0.9925461411476135, -8.329467959811154e-8, 0.12186941504478455, 0,
                -0.08617465943098068, 0.7071066498756409, 0.7018361687660217, 0,
                -0.08617471158504486, -0.7071068286895752, 0.7018359303474426, 0,
                0.003979798872023821, -0.015857888385653496, 0.049641866236925125, 1,
            ],
            numHapticActuators: 1,
        },
    },
};
const metaQuestTouchPro = {
    profileId: 'meta-quest-touch-pro',
    fallbackProfileIds: [
        'oculus-touch-v2',
        'oculus-touch',
        'generic-trigger-squeeze-thumbstick',
    ],
    layout: {
        left: {
            gamepad: gamepadConfigLeft,
            gripOffsetMatrix: [
                0.9925461411476135, -1.5779937356796836e-8, -0.12186935544013977, 0,
                0.08617467433214188, 0.7071067094802856, 0.701836109161377, 0,
                0.0861746296286583, -0.7071067690849304, 0.7018360495567322, 0,
                -0.003979836590588093, -0.015857847407460213, 0.049641840159893036, 1,
            ],
            numHapticActuators: 3,
        },
        right: {
            gamepad: gamepadConfigRight,
            gripOffsetMatrix: [
                0.9925461411476135, 9.267653311439972e-11, 0.12186937034130096, 0,
                -0.08617467433214188, 0.7071067094802856, 0.7018361687660217, 0,
                -0.08617464452981949, -0.7071067690849304, 0.7018360495567322, 0,
                0.003979847766458988, -0.01585782691836357, 0.04964186251163483, 1,
            ],
            numHapticActuators: 3,
        },
    },
};
const metaQuestTouchPlus = {
    profileId: 'meta-quest-touch-plus',
    fallbackProfileIds: [
        'oculus-touch-v3',
        'oculus-touch',
        'generic-trigger-squeeze-thumbstick',
    ],
    layout: {
        left: {
            gamepad: gamepadConfigLeft,
            gripOffsetMatrix: [
                0.9925461411476135, 1.0736208366779465e-8, -0.12186933308839798, 0,
                0.08617459982633591, 0.70710688829422, 0.7018360495567322, 0,
                0.08617466688156128, -0.7071067094802856, 0.7018362283706665, 0,
                -0.003979803062975407, -0.015857873484492302, 0.04964187368750572, 1,
            ],
            numHapticActuators: 1,
        },
        right: {
            gamepad: gamepadConfigRight,
            gripOffsetMatrix: [
                0.9925461411476135, -2.6238110351073374e-8, 0.12186934053897858, 0,
                -0.0861746147274971, 0.7071067690849304, 0.7018360495567322, 0,
                -0.08617465943098068, -0.7071067094802856, 0.701836109161377, 0,
                0.003979838453233242, -0.015857869759202003, 0.04964182525873184, 1,
            ],
            numHapticActuators: 1,
        },
    },
};

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const oculusQuest1 = {
    name: 'Oculus Quest 1',
    controllerConfig: oculusTouchV2,
    supportedSessionModes: [
        XRSessionMode.Inline,
        XRSessionMode.ImmersiveVR,
        XRSessionMode.ImmersiveAR,
    ],
    supportedFeatures: [
        WebXRFeatures.Viewer,
        WebXRFeatures.Local,
        WebXRFeatures.LocalFloor,
        WebXRFeatures.BoundedFloor,
        WebXRFeatures.Unbounded,
        WebXRFeatures.Anchors,
        WebXRFeatures.PlaneDetection,
        WebXRFeatures.HandTracking,
    ],
    supportedFrameRates: [72, 80, 90],
    isSystemKeyboardSupported: true,
    internalNominalFrameRate: 72,
    environmentBlendModes: {
        [XRSessionMode.ImmersiveVR]: XREnvironmentBlendMode.Opaque,
        [XRSessionMode.ImmersiveAR]: XREnvironmentBlendMode.AlphaBlend,
    },
    interactionMode: XRInteractionMode.WorldSpace,
    userAgent: 'Mozilla/5.0 (X11; Linux x86_64; Quest 1) AppleWebKit/537.36 (KHTML, like Gecko) OculusBrowser/33.0.0.x.x.x Chrome/126.0.6478.122 VR Safari/537.36',
};
const metaQuest2 = {
    name: 'Meta Quest 2',
    controllerConfig: oculusTouchV3,
    supportedSessionModes: [
        XRSessionMode.Inline,
        XRSessionMode.ImmersiveVR,
        XRSessionMode.ImmersiveAR,
    ],
    supportedFeatures: [
        WebXRFeatures.Viewer,
        WebXRFeatures.Local,
        WebXRFeatures.LocalFloor,
        WebXRFeatures.BoundedFloor,
        WebXRFeatures.Unbounded,
        WebXRFeatures.Anchors,
        WebXRFeatures.PlaneDetection,
        WebXRFeatures.MeshDetection,
        WebXRFeatures.HitTest,
        WebXRFeatures.HandTracking,
    ],
    supportedFrameRates: [72, 80, 90, 120],
    isSystemKeyboardSupported: true,
    internalNominalFrameRate: 72,
    environmentBlendModes: {
        [XRSessionMode.ImmersiveVR]: XREnvironmentBlendMode.Opaque,
        [XRSessionMode.ImmersiveAR]: XREnvironmentBlendMode.AlphaBlend,
    },
    interactionMode: XRInteractionMode.WorldSpace,
    userAgent: 'Mozilla/5.0 (X11; Linux x86_64; Quest 2) AppleWebKit/537.36 (KHTML, like Gecko) OculusBrowser/33.0.0.x.x.x Chrome/126.0.6478.122 VR Safari/537.36',
};
const metaQuestPro = {
    name: 'Meta Quest Pro',
    controllerConfig: metaQuestTouchPro,
    supportedSessionModes: [
        XRSessionMode.Inline,
        XRSessionMode.ImmersiveVR,
        XRSessionMode.ImmersiveAR,
    ],
    supportedFeatures: [
        WebXRFeatures.Viewer,
        WebXRFeatures.Local,
        WebXRFeatures.LocalFloor,
        WebXRFeatures.BoundedFloor,
        WebXRFeatures.Unbounded,
        WebXRFeatures.Anchors,
        WebXRFeatures.PlaneDetection,
        WebXRFeatures.MeshDetection,
        WebXRFeatures.HitTest,
        WebXRFeatures.HandTracking,
    ],
    supportedFrameRates: [72, 80, 90, 120],
    isSystemKeyboardSupported: true,
    internalNominalFrameRate: 90,
    environmentBlendModes: {
        [XRSessionMode.ImmersiveVR]: XREnvironmentBlendMode.Opaque,
        [XRSessionMode.ImmersiveAR]: XREnvironmentBlendMode.AlphaBlend,
    },
    interactionMode: XRInteractionMode.WorldSpace,
    userAgent: 'Mozilla/5.0 (X11; Linux x86_64; Quest Pro) AppleWebKit/537.36 (KHTML, like Gecko) OculusBrowser/33.0.0.x.x.x Chrome/126.0.6478.122 VR Safari/537.36',
};
const metaQuest3 = {
    name: 'Meta Quest 3',
    controllerConfig: metaQuestTouchPlus,
    supportedSessionModes: [
        XRSessionMode.Inline,
        XRSessionMode.ImmersiveVR,
        XRSessionMode.ImmersiveAR,
    ],
    supportedFeatures: [
        WebXRFeatures.Viewer,
        WebXRFeatures.Local,
        WebXRFeatures.LocalFloor,
        WebXRFeatures.BoundedFloor,
        WebXRFeatures.Unbounded,
        WebXRFeatures.Anchors,
        WebXRFeatures.PlaneDetection,
        WebXRFeatures.MeshDetection,
        WebXRFeatures.HitTest,
        WebXRFeatures.HandTracking,
        WebXRFeatures.DepthSensing,
    ],
    supportedFrameRates: [72, 80, 90, 120],
    isSystemKeyboardSupported: true,
    internalNominalFrameRate: 90,
    environmentBlendModes: {
        [XRSessionMode.ImmersiveVR]: XREnvironmentBlendMode.Opaque,
        [XRSessionMode.ImmersiveAR]: XREnvironmentBlendMode.AlphaBlend,
    },
    interactionMode: XRInteractionMode.WorldSpace,
    userAgent: 'Mozilla/5.0 (X11; Linux x86_64; Quest 3) AppleWebKit/537.36 (KHTML, like Gecko) OculusBrowser/33.0.0.x.x.x Chrome/126.0.6478.122 VR Safari/537.36',
};

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const PRIVATE = Symbol('@immersive-web-emulation-runtime/action-recorder');
const compress = (arr) => {
    const out = [];
    arr.forEach((num) => {
        out.push(parseFloat(num.toFixed(3)));
    });
    return out;
};
class ActionRecorder {
    constructor(session, refSpace) {
        this[PRIVATE] = {
            session,
            refSpace,
            inputMap: new Map(),
            schemaMap: new Map(),
            compressedFrames: [],
            jointRadii: new Float32Array(25),
            jointTransforms: new Float32Array(25 * 16),
        };
    }
    recordFrame(frame) {
        var _a;
        const timeStamp = performance.now();
        const viewerMatrix = (_a = frame.getViewerPose(this[PRIVATE].refSpace)) === null || _a === void 0 ? void 0 : _a.transform.matrix;
        if (!viewerMatrix)
            return;
        const position = getTranslation(create$2(), viewerMatrix);
        const quaternion = getRotation(create(), viewerMatrix);
        const actionFrame = {
            timeStamp,
            position,
            quaternion,
            inputFrames: [],
        };
        this[PRIVATE].session.inputSources.forEach((inputSource) => {
            var _a, _b;
            if (!this[PRIVATE].inputMap.has(inputSource)) {
                const schema = {
                    handedness: inputSource.handedness,
                    targetRayMode: inputSource.targetRayMode,
                    profiles: inputSource.profiles,
                    hasGrip: inputSource.gripSpace != null,
                    hasHand: inputSource.hand != null,
                    hasGamepad: inputSource.gamepad != null,
                };
                if (schema.hasHand) {
                    schema.jointSequence = Array.from(inputSource.hand.values()).map((jointSpace) => jointSpace.jointName);
                }
                if (schema.hasGamepad) {
                    schema.mapping = inputSource.gamepad.mapping;
                    schema.numButtons = inputSource.gamepad.buttons.length;
                    schema.numAxes = inputSource.gamepad.axes.length;
                }
                const index = this[PRIVATE].inputMap.size;
                this[PRIVATE].inputMap.set(inputSource, index);
                this[PRIVATE].schemaMap.set(index, schema);
            }
            const index = this[PRIVATE].inputMap.get(inputSource);
            const schema = this[PRIVATE].schemaMap.get(index);
            const targetRayMatrix = (_a = frame.getPose(inputSource.targetRaySpace, this[PRIVATE].refSpace)) === null || _a === void 0 ? void 0 : _a.transform.matrix;
            if (targetRayMatrix) {
                const targetRayPosition = getTranslation(create$2(), targetRayMatrix);
                const targetRayQuaternion = getRotation(create(), targetRayMatrix);
                const inputFrame = {
                    index,
                    targetRayTransform: {
                        position: targetRayPosition,
                        quaternion: targetRayQuaternion,
                    },
                };
                if (schema.hasGrip) {
                    const gripMatrix = (_b = frame.getPose(inputSource.gripSpace, this[PRIVATE].refSpace)) === null || _b === void 0 ? void 0 : _b.transform.matrix;
                    if (gripMatrix) {
                        const position = getTranslation(create$2(), gripMatrix);
                        const quaternion = getRotation(create(), gripMatrix);
                        inputFrame.gripTransform = {
                            position,
                            quaternion,
                        };
                    }
                }
                if (schema.hasHand) {
                    const jointSpaces = Array.from(inputSource.hand.values());
                    let allValid = true;
                    // @ts-ignore
                    allValid && (allValid = frame.fillPoses(jointSpaces, inputSource.targetRaySpace, this[PRIVATE].jointTransforms));
                    // @ts-ignore
                    allValid && (allValid = frame.fillJointRadii(jointSpaces, this[PRIVATE].jointRadii));
                    if (allValid) {
                        const hand = {};
                        for (let offset = 0; offset < 25; offset++) {
                            const jointMatrix = this[PRIVATE].jointTransforms.slice(offset * 16, (offset + 1) * 16);
                            const radius = this[PRIVATE].jointRadii[offset];
                            const position = getTranslation(create$2(), jointMatrix);
                            const quaternion = getRotation(create(), jointMatrix);
                            const jointName = jointSpaces[offset].jointName;
                            hand[jointName] = { position, quaternion, radius };
                        }
                        inputFrame.hand = hand;
                    }
                }
                if (schema.hasGamepad) {
                    const gamepad = {
                        buttons: inputSource.gamepad.buttons.map((button) => button
                            ? [button.pressed ? 1 : 0, button.touched ? 1 : 0, button.value]
                            : null),
                        axes: Array.from(inputSource.gamepad.axes),
                    };
                    inputFrame.gamepad = gamepad;
                }
                actionFrame.inputFrames.push(inputFrame);
            }
        });
        this[PRIVATE].compressedFrames.push(this.compressActionFrame(actionFrame));
    }
    compressActionFrame(af) {
        const out = [
            Math.round(af.timeStamp * 10) / 10,
            ...compress(af.position),
            ...compress(af.quaternion),
        ];
        af.inputFrames.forEach((inputFrame) => {
            const index = inputFrame.index;
            const schema = this[PRIVATE].schemaMap.get(index);
            const inputOut = [
                index,
                ...compress(inputFrame.targetRayTransform.position),
                ...compress(inputFrame.targetRayTransform.quaternion),
            ];
            if (schema.hasGrip) {
                inputOut.push([
                    ...compress(inputFrame.gripTransform.position),
                    ...compress(inputFrame.gripTransform.quaternion),
                ]);
            }
            if (schema.hasHand) {
                const handArr = [];
                Object.values(inputFrame.hand).forEach(({ position, quaternion, radius }) => {
                    handArr.push(...compress(position), ...compress(quaternion), parseFloat(radius.toFixed(3)));
                });
                inputOut.push(handArr);
            }
            if (schema.hasGamepad) {
                inputOut.push([
                    ...inputFrame.gamepad.buttons,
                    ...inputFrame.gamepad.axes,
                ]);
            }
            out.push(inputOut);
        });
        return out;
    }
    log() {
        const out = {
            schema: Array.from(this[PRIVATE].schemaMap.entries()),
            frames: this[PRIVATE].compressedFrames,
        };
        console.log(JSON.stringify(out));
    }
}

export { ActionRecorder, XRDevice, XRFrame, XRHand, XRInputSource, XRInputSourceArray, XRInputSourceEvent, XRInputSourcesChangeEvent, XRJointPose, XRJointSpace, XRLayer, XRPose, XRReferenceSpace, XRReferenceSpaceEvent, XRRenderState, XRRigidTransform, XRSession, XRSessionEvent, XRSpace, XRSystem, XRView, XRViewerPose, XRViewport, XRWebGLLayer, metaQuest2, metaQuest3, metaQuestPro, oculusQuest1 };
