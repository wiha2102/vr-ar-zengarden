import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { Button, ButtonContainer, ButtonGroup, FAIcon, MappedKeyBlock, RangeSelector, } from './styled.js';
import { useEffect, useState } from 'react';
import { GamepadIcon } from './icons.js';
import { MappedKeyDisplay } from './keys.js';
import { faFingerprint } from '@fortawesome/free-solid-svg-icons';
export const AnalogButton = ({ xrController, buttonId, pointerLocked, mappedKey, }) => {
    const [isTouched, setIsTouched] = useState(false);
    const [isPressed, setIsPressed] = useState(false);
    const [isKeyPressed, setIsKeyPressed] = useState(false);
    const [analogValue, setAnalogValue] = useState(0);
    const handedness = xrController.inputSource.handedness;
    useEffect(() => {
        const handleKeyDown = (event) => {
            if (event.code === mappedKey) {
                xrController.updateButtonValue(buttonId, 1);
                setIsKeyPressed(true);
            }
        };
        const handleKeyUp = (event) => {
            if (event.code === mappedKey) {
                xrController.updateButtonValue(buttonId, 0);
                setIsKeyPressed(false);
            }
        };
        const handleMouseDown = (event) => {
            if (mappedKey === 'MouseLeft' && event.button === 0) {
                xrController.updateButtonValue(buttonId, 1);
                setIsKeyPressed(true);
            }
            else if (mappedKey === 'MouseRight' && event.button === 2) {
                xrController.updateButtonValue(buttonId, 1);
                setIsKeyPressed(true);
            }
        };
        const handleMouseUp = (event) => {
            if (mappedKey === 'MouseLeft' && event.button === 0) {
                xrController.updateButtonValue(buttonId, 0);
                setIsKeyPressed(false);
            }
            else if (mappedKey === 'MouseRight' && event.button === 2) {
                xrController.updateButtonValue(buttonId, 0);
                setIsKeyPressed(false);
            }
        };
        if (pointerLocked) {
            if (mappedKey === 'MouseLeft' || mappedKey === 'MouseRight') {
                window.addEventListener('mousedown', handleMouseDown);
                window.addEventListener('mouseup', handleMouseUp);
            }
            else {
                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
            }
        }
        else {
            if (mappedKey === 'MouseLeft' || mappedKey === 'MouseRight') {
                window.removeEventListener('mousedown', handleMouseDown);
                window.removeEventListener('mouseup', handleMouseUp);
            }
            else {
                window.removeEventListener('keydown', handleKeyDown);
                window.removeEventListener('keyup', handleKeyUp);
            }
        }
        return () => {
            if (mappedKey === 'MouseLeft' || mappedKey === 'MouseRight') {
                window.removeEventListener('mousedown', handleMouseDown);
                window.removeEventListener('mouseup', handleMouseUp);
            }
            else {
                window.removeEventListener('keydown', handleKeyDown);
                window.removeEventListener('keyup', handleKeyUp);
            }
        };
    }, [mappedKey, pointerLocked, buttonId, xrController]);
    return (_jsxs(ButtonContainer, { "$reverse": handedness === 'right', children: [_jsx(GamepadIcon, { buttonName: buttonId, handedness: handedness }), _jsx(ButtonGroup, { "$reverse": handedness === 'right', children: pointerLocked ? (_jsx(MappedKeyBlock, { "$pressed": isKeyPressed, children: MappedKeyDisplay[mappedKey] })) : (_jsxs(_Fragment, { children: [_jsx(Button, { "$reverse": handedness === 'right', style: {
                                backgroundColor: isPressed
                                    ? 'rgba(255, 255, 255, 0.6)'
                                    : 'rgba(255, 255, 255, 0.3)',
                                width: '50px',
                            }, onClick: () => {
                                setIsPressed(true);
                                xrController.updateButtonValue(buttonId, 1);
                                setTimeout(() => {
                                    setIsPressed(false);
                                    xrController.updateButtonValue(buttonId, 0);
                                }, 500);
                            }, children: "Press" }), _jsx(Button, { "$reverse": handedness === 'right', style: {
                                backgroundColor: isTouched
                                    ? 'rgba(255, 255, 255, 0.6)'
                                    : 'rgba(255, 255, 255, 0.3)',
                                width: '29px',
                            }, onClick: () => {
                                setIsTouched(!isTouched);
                                xrController.updateButtonTouch(buttonId, !isTouched);
                            }, children: _jsx(FAIcon, { icon: faFingerprint }) }), _jsx(RangeSelector, { "$reverse": handedness === 'right', value: analogValue, onChange: (e) => {
                                const value = Number(e.target.value);
                                setAnalogValue(value);
                                xrController.updateButtonValue(buttonId, value / 100);
                            }, min: "0", max: "100" })] })) })] }));
};
//# sourceMappingURL=analog.js.map